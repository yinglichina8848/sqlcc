# SQLCC 错误处理机制设计

本文档定义了SQLCC解析器新的错误处理机制设计，采用结构化错误信息、多错误收集和错误恢复策略。

## 1. 错误处理总体架构

### 1.1 设计目标

1. **结构化错误信息**：提供详细的位置信息、错误类型和修复建议
2. **多错误收集**：不因单个错误停止解析，收集所有错误信息
3. **错误恢复机制**：支持Panic Mode Recovery，尽可能继续解析
4. **错误分类**：按严重程度和类型分类错误，便于处理
5. **调试友好**：提供清晰的错误消息和上下文信息

### 1.2 错误处理层次

```
错误处理系统
├── 词法错误 (Lexical Errors)
│   ├── 无效字符
│   ├── 未终止字符串
│   └── 无效数字格式
├── 语法错误 (Syntax Errors)
│   ├── 意外token
│   ├── 缺少必需token
│   └── 无效语法结构
├── 语义错误 (Semantic Errors)
│   ├── 未定义标识符
│   ├── 类型不匹配
│   └── 约束违反
└── 运行时错误 (Runtime Errors)
    ├── 内存不足
    ├── 栈溢出
    └── 内部错误
```

## 2. 核心错误类定义

### 2.1 基础错误类

```cpp
class ParseError {
public:
    enum ErrorType {
        // 词法错误
        LEXICAL_INVALID_CHARACTER,
        LEXICAL_UNTERMINATED_STRING,
        LEXICAL_INVALID_NUMBER,

        // 语法错误
        SYNTAX_UNEXPECTED_TOKEN,
        SYNTAX_MISSING_TOKEN,
        SYNTAX_INVALID_SYNTAX,

        // 语义错误
        SEMANTIC_UNDEFINED_IDENTIFIER,
        SEMANTIC_TYPE_MISMATCH,
        SEMANTIC_CONSTRAINT_VIOLATION,

        // 其他错误
        INTERNAL_ERROR,
        WARNING
    };

    enum Severity {
        INFO,       // 信息
        WARNING,    // 警告
        ERROR,      // 错误
        FATAL       // 致命错误
    };

    ParseError(ErrorType type,
               Severity severity,
               const std::string& message,
               const SourceLocation& location = SourceLocation());

    ErrorType getErrorType() const;
    Severity getSeverity() const;
    const std::string& getMessage() const;
    const SourceLocation& getLocation() const;

    // 错误修复建议
    const std::string& getSuggestion() const;
    void setSuggestion(const std::string& suggestion);

    // 错误上下文
    const std::string& getContext() const;
    void setContext(const std::string& context);

    // 格式化输出
    std::string toString() const;
    std::string toJson() const;

private:
    ErrorType type_;
    Severity severity_;
    std::string message_;
    SourceLocation location_;
    std::string suggestion_;
    std::string context_;
};
```

### 2.2 错误收集器

```cpp
class ErrorCollector {
public:
    void addError(std::unique_ptr<ParseError> error);
    void addWarning(const std::string& message, const SourceLocation& location = SourceLocation());
    void addInfo(const std::string& message, const SourceLocation& location = SourceLocation());

    // 查询方法
    const std::vector<std::unique_ptr<ParseError>>& getErrors() const;
    const std::vector<std::unique_ptr<ParseError>>& getWarnings() const;
    bool hasErrors() const;
    bool hasFatalErrors() const;
    size_t getErrorCount() const;
    size_t getWarningCount() const;

    // 按类型过滤
    std::vector<std::unique_ptr<ParseError>> getErrorsByType(ParseError::ErrorType type) const;
    std::vector<std::unique_ptr<ParseError>> getErrorsBySeverity(ParseError::Severity severity) const;

    // 清除错误
    void clear();
    void clearErrors();
    void clearWarnings();

    // 格式化输出
    std::string toString() const;
    std::string toJson() const;

private:
    std::vector<std::unique_ptr<ParseError>> errors_;
    std::vector<std::unique_ptr<ParseError>> warnings_;
};
```

## 3. 错误恢复机制

### 3.1 Panic Mode Recovery

```cpp
class ErrorRecovery {
public:
    enum RecoveryStrategy {
        SKIP_TO_NEXT_STATEMENT,    // 跳到下一条语句
        SKIP_TO_NEXT_TOKEN,        // 跳到下一个token
        INSERT_MISSING_TOKEN,      // 插入缺失的token
        REPLACE_INVALID_TOKEN,     // 替换无效token
        ABORT_PARSING             // 停止解析
    };

    struct RecoveryResult {
        RecoveryStrategy strategy;
        std::vector<Token> insertedTokens;
        std::vector<Token> skippedTokens;
        SourceLocation recoveryLocation;
    };

    static RecoveryResult recoverFromError(const ParseError& error,
                                         const TokenStream& tokenStream,
                                         const std::string& input);

private:
    // 语句边界检测
    static bool isStatementBoundary(const Token& token);
    static SourceLocation findNextStatementBoundary(const TokenStream& tokenStream);

    // Token插入策略
    static std::vector<Token> suggestMissingTokens(const ParseError& error);
    static Token createExpectedToken(ParseError::ErrorType errorType);
};
```

### 3.2 语法分析器错误恢复

```cpp
class Parser {
public:
    Parser(const std::string& input, ErrorCollector& errorCollector);

    // 解析方法
    std::vector<std::unique_ptr<Statement>> parse();

    // 错误处理方法
    void reportError(ParseError::ErrorType type,
                    const std::string& message,
                    const SourceLocation& location = SourceLocation());

    void reportWarning(const std::string& message,
                      const SourceLocation& location = SourceLocation());

    // 错误恢复
    bool tryRecoverFromError();
    void skipToNextStatement();
    void skipToNextToken(Token::Type expectedType);

private:
    std::string input_;
    TokenStream tokenStream_;
    ErrorCollector& errorCollector_;
    bool recoveryMode_;

    // 解析状态
    std::stack<ParseContext> contextStack_;

    // 错误恢复辅助方法
    bool canRecoverFromError(const ParseError& error) const;
    void enterRecoveryMode();
    void exitRecoveryMode();
};
```

## 4. 词法分析器错误处理

### 4.1 词法错误检测

```cpp
class Lexer {
public:
    Lexer(const std::string& input, ErrorCollector& errorCollector);

    Token nextToken();

private:
    std::string input_;
    size_t position_;
    ErrorCollector& errorCollector_;

    // 错误处理方法
    void reportLexicalError(LexicalError::Type type,
                           const std::string& message,
                           size_t position);

    // 错误恢复
    void skipInvalidCharacter();
    void recoverFromUnterminatedString();
    void recoverFromInvalidNumber();

    // 上下文信息
    std::string getErrorContext(size_t position, size_t contextLength = 50) const;
};
```

### 4.2 词法错误类型

```cpp
namespace LexicalError {
    enum Type {
        INVALID_CHARACTER,      // 无效字符
        UNTERMINATED_STRING,    // 未终止字符串
        INVALID_STRING_ESCAPE,  // 无效字符串转义
        INVALID_NUMBER_FORMAT,  // 无效数字格式
        IDENTIFIER_TOO_LONG,    // 标识符过长
        COMMENT_TOO_LONG        // 注释过长
    };

    static std::string getErrorMessage(Type type) {
        switch (type) {
            case INVALID_CHARACTER:
                return "Invalid character encountered";
            case UNTERMINATED_STRING:
                return "Unterminated string literal";
            case INVALID_STRING_ESCAPE:
                return "Invalid escape sequence in string";
            case INVALID_NUMBER_FORMAT:
                return "Invalid number format";
            case IDENTIFIER_TOO_LONG:
                return "Identifier too long";
            case COMMENT_TOO_LONG:
                return "Comment too long";
            default:
                return "Unknown lexical error";
        }
    }
}
```

## 5. 语义分析错误处理

### 5.1 语义错误检测

```cpp
class SemanticAnalyzer {
public:
    SemanticAnalyzer(SymbolTable& symbolTable, ErrorCollector& errorCollector);

    void analyze(std::unique_ptr<ASTNode>& ast);

private:
    SymbolTable& symbolTable_;
    ErrorCollector& errorCollector_;

    // 错误检测方法
    void checkUndefinedIdentifier(const IdentifierExpression& expr);
    void checkTypeMismatch(const BinaryExpression& expr);
    void checkConstraintViolation(const CreateStatement& stmt);

    // 错误报告
    void reportSemanticError(SemanticError::Type type,
                           const std::string& message,
                           const SourceLocation& location);
};
```

### 5.2 语义错误类型

```cpp
namespace SemanticError {
    enum Type {
        UNDEFINED_TABLE,        // 未定义的表
        UNDEFINED_COLUMN,       // 未定义的列
        UNDEFINED_FUNCTION,     // 未定义的函数
        DUPLICATE_TABLE,        // 重复的表名
        DUPLICATE_COLUMN,       // 重复的列名
        TYPE_MISMATCH,          // 类型不匹配
        INVALID_CONSTRAINT,     // 无效约束
        INVALID_JOIN_CONDITION, // 无效JOIN条件
        AMBIGUOUS_COLUMN,       // 歧义列引用
        DIVISION_BY_ZERO,       // 除零错误
        INVALID_AGGREGATE,      // 无效聚合函数使用
        INVALID_WINDOW_FUNCTION // 无效窗口函数使用
    };

    static std::string getErrorMessage(Type type) {
        switch (type) {
            case UNDEFINED_TABLE:
                return "Undefined table";
            case UNDEFINED_COLUMN:
                return "Undefined column";
            case TYPE_MISMATCH:
                return "Type mismatch";
            // ... 其他错误消息
            default:
                return "Unknown semantic error";
        }
    }
}
```

## 6. 错误报告和格式化

### 6.1 错误格式化器

```cpp
class ErrorFormatter {
public:
    enum Format {
        CONSOLE,    // 控制台格式
        JSON,       // JSON格式
        XML,        // XML格式
        HTML        // HTML格式
    };

    static std::string format(const ErrorCollector& errors,
                            Format format = CONSOLE);

    static std::string formatSingleError(const ParseError& error,
                                       Format format = CONSOLE);

private:
    // 控制台格式化
    static std::string formatConsole(const ErrorCollector& errors);
    static std::string formatConsoleSingle(const ParseError& error);

    // JSON格式化
    static std::string formatJson(const ErrorCollector& errors);
    static std::string formatJsonSingle(const ParseError& error);

    // 辅助方法
    static std::string getSeverityColor(ParseError::Severity severity);
    static std::string getSeverityIcon(ParseError::Severity severity);
    static std::string escapeJsonString(const std::string& str);
};
```

### 6.2 错误统计

```cpp
class ErrorStatistics {
public:
    void collect(const ErrorCollector& errors);

    size_t getTotalErrors() const;
    size_t getTotalWarnings() const;
    size_t getErrorsByType(ParseError::ErrorType type) const;
    size_t getErrorsBySeverity(ParseError::Severity severity) const;

    // 错误分布
    std::map<size_t, size_t> getErrorsByLine() const;  // 按行统计错误
    std::map<std::string, size_t> getErrorsByFile() const;  // 按文件统计错误

    // 报告生成
    std::string generateReport() const;
    std::string generateSummary() const;

private:
    std::map<ParseError::ErrorType, size_t> errorTypeCounts_;
    std::map<ParseError::Severity, size_t> severityCounts_;
    std::map<size_t, size_t> lineErrorCounts_;
    std::map<std::string, size_t> fileErrorCounts_;
};
```

## 7. 配置和选项

### 7.1 错误处理配置

```cpp
struct ErrorHandlingConfig {
    // 错误处理策略
    bool continueOnErrors;        // 遇到错误时是否继续解析
    bool collectAllErrors;        // 是否收集所有错误
    size_t maxErrors;             // 最大错误数量限制

    // 错误恢复策略
    bool enableRecovery;          // 是否启用错误恢复
    ErrorRecovery::RecoveryStrategy defaultRecoveryStrategy;

    // 错误报告
    ErrorFormatter::Format outputFormat;  // 输出格式
    bool showContext;            // 是否显示上下文
    bool showSuggestions;        // 是否显示修复建议
    size_t contextLines;         // 上下文行数

    // 调试选项
    bool verboseErrors;          // 详细错误信息
    bool stackTrace;             // 包含栈跟踪
};
```

### 7.2 配置管理

```cpp
class ErrorConfigManager {
public:
    static ErrorHandlingConfig getDefaultConfig();
    static ErrorHandlingConfig getStrictConfig();    // 严格模式
    static ErrorHandlingConfig getLenientConfig();   // 宽松模式

    static void loadConfig(const std::string& configFile);
    static void saveConfig(const std::string& configFile, const ErrorHandlingConfig& config);

    static bool validateConfig(const ErrorHandlingConfig& config);
};
```

## 8. 实现注意事项

### 8.1 性能考虑
- 错误对象应该轻量化，避免影响正常解析性能
- 错误收集应该使用高效的数据结构
- 错误格式化应该是懒计算的

### 8.2 内存管理
- 使用智能指针管理错误对象
- 避免错误信息占用过多内存
- 支持错误对象的池化复用

### 8.3 线程安全
- 错误收集器应该是线程安全的
- 支持并发解析的错误收集
- 错误格式化器应该是无状态的

### 8.4 扩展性
- 支持自定义错误类型
- 插件架构支持第三方错误处理器
- 支持错误处理的国际化

### 8.5 测试性
- 错误处理逻辑应该易于测试
- 支持错误注入用于测试
- 提供错误处理的模拟框架

---

*本文档定义了SQLCC解析器新的错误处理机制，为解析器的健壮性和用户体验奠定基础。*
