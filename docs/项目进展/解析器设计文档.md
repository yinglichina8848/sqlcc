# SQLCC 解析器设计文档

## 概述

本文档详细描述了SQLCC项目SQL解析器的新设计方案，包括词法解析器和语法解析器的架构设计、数据结构定义、错误处理机制等。

## 设计原则

1. **模块化**：词法解析器和语法解析器分离，各自独立可测试
2. **可扩展性**：易于添加新的SQL特性和关键字
3. **性能**：高效的解析算法，最小化内存分配
4. **错误处理**：提供详细的错误信息和恢复机制
5. **可维护性**：清晰的代码结构和文档

## 词法解析器设计

### 1. 架构概述

新的词法解析器将采用确定性有限状态自动机（DFA）设计，使用状态表驱动而非大量if-else判断，提高效率和可维护性。

### 2. 状态机设计

#### 2.1 状态定义

```cpp
enum class LexerState {
    START,          // 初始状态
    IN_IDENTIFIER,  // 标识符/关键字
    IN_NUMBER,      // 数字
    IN_STRING,      // 字符串
    IN_OPERATOR,    // 操作符
    IN_COMMENT,     // 注释
    DONE            // 完成状态
};
```

#### 2.2 状态转换表

使用二维数组表示状态转换，行表示当前状态，列表示输入字符类型，值表示下一状态。

### 3. Token类型重新设计

#### 3.1 Token分类

将Token类型按功能分类，提高可读性和可维护性：

```cpp
enum class TokenType {
    // 特殊标记
    END_OF_INPUT,
    
    // 标点符号
    LEFT_PAREN,
    RIGHT_PAREN,
    COMMA,
    DOT,
    SEMICOLON,
    
    // 操作符
    PLUS,
    MINUS,
    MULTIPLY,
    DIVIDE,
    EQUAL,
    NOT_EQUAL,
    LESS,
    LESS_EQUAL,
    GREATER,
    GREATER_EQUAL,
    
    // 字面量
    IDENTIFIER,
    STRING,
    NUMBER,
    
    // 关键字 - DDL
    K_CREATE,
    K_DROP,
    K_ALTER,
    K_TABLE,
    K_INDEX,
    K_DATABASE,
    
    // 关键字 - DML
    K_SELECT,
    K_INSERT,
    K_UPDATE,
    K_DELETE,
    K_FROM,
    K_WHERE,
    K_INTO,
    K_VALUES,
    K_SET,
    
    // 关键字 - 聚合函数
    K_COUNT,
    K_SUM,
    K_AVG,
    K_MIN,
    K_MAX,
    K_DISTINCT,
    
    // 关键字 - 子句
    K_GROUP,
    K_BY,
    K_ORDER,
    K_HAVING,
    K_LIMIT,
    K_OFFSET,
    
    // 关键字 - 连接
    K_JOIN,
    K_INNER,
    K_LEFT,
    K_RIGHT,
    K_FULL,
    K_ON,
    
    // 关键字 - 约束
    K_PRIMARY,
    K_KEY,
    K_FOREIGN,
    K_REFERENCES,
    K_NOT,
    K_NULL,
    K_UNIQUE,
    K_CHECK,
    K_DEFAULT,
    K_AUTO_INCREMENT,
    
    // 关键字 - 其他
    K_AND,
    K_OR,
    K_NOT,
    K_EXISTS,
    K_IN,
    K_BETWEEN,
    K_LIKE,
    K_IS,
    K_TRUE,
    K_FALSE,
    K_ASC,
    K_DESC,
    K_UNION,
    K_INTERSECT,
    K_EXCEPT,
    K_ALL,
    
    // 关键字 - DCL
    K_GRANT,
    K_REVOKE,
    K_USER,
    K_PRIVILEGES,
    K_TO,
    K_WITH,
    K_PASSWORD,
    K_IDENTIFIED,
    
    // 关键字 - 显示
    K_SHOW,
    K_DATABASES,
    K_TABLES,
    K_COLUMNS,
    K_INDEXES,
    K_GRANTS
};
```

### 4. 词法解析器实现

#### 4.1 类设计

```cpp
class Lexer {
public:
    explicit Lexer(const std::string& input);
    Token nextToken();
    
private:
    // 状态机相关
    LexerState state_;
    int position_;
    int line_;
    int column_;
    std::string input_;
    
    // 辅助方法
    char advance();
    char peek() const;
    char peekNext() const;
    bool isAtEnd() const;
    
    // 状态处理方法
    Token handleStartState();
    Token handleIdentifierState();
    Token handleNumberState();
    Token handleStringState();
    Token handleOperatorState();
    Token handleCommentState();
    
    // 辅助方法
    Token createToken(TokenType type, const std::string& lexeme);
    bool isKeyword(const std::string& identifier) const;
    TokenType getKeywordType(const std::string& identifier) const;
    
    // 注释处理
    void skipLineComment();
    void skipBlockComment();
};
```

#### 4.2 状态表实现

使用静态常量数组定义状态转换表，提高性能。

## 语法解析器设计

### 1. 解析方法选择

采用递归下降解析器（Recursive Descent Parser），因为它：
- 易于理解和实现
- 提供良好的错误处理
- 易于调试和维护
- 适合SQL这类相对简单的语法

### 2. AST设计

#### 2.1 基础节点

```cpp
// 基础AST节点
class ASTNode {
public:
    virtual ~ASTNode() = default;
    virtual void accept(ASTVisitor& visitor) = 0;
};

// 语句基类
class Statement : public ASTNode {
public:
    virtual ~Statement() = default;
};

// 表达式基类
class Expression : public ASTNode {
public:
    virtual ~Expression() = default;
};
```

#### 2.2 语句节点

```cpp
// SELECT语句
class SelectStatement : public Statement {
public:
    std::vector<std::unique_ptr<Expression>> selectList;
    std::unique_ptr<TableReference> fromClause;
    std::unique_ptr<Expression> whereClause;
    std::vector<std::unique_ptr<Expression>> groupByClause;
    std::unique_ptr<Expression> havingClause;
    std::vector<std::unique_ptr<OrderExpression>> orderByClause;
    std::unique_ptr<Expression> limitClause;
    std::unique_ptr<Expression> offsetClause;
    
    void accept(ASTVisitor& visitor) override;
};

// INSERT语句
class InsertStatement : public Statement {
public:
    std::string tableName;
    std::vector<std::string> columns;
    std::vector<std::vector<std::unique_ptr<Expression>>> values;
    
    void accept(ASTVisitor& visitor) override;
};

// UPDATE语句
class UpdateStatement : public Statement {
public:
    std::string tableName;
    std::vector<std::pair<std::string, std::unique_ptr<Expression>>> setClause;
    std::unique_ptr<Expression> whereClause;
    
    void accept(ASTVisitor& visitor) override;
};

// DELETE语句
class DeleteStatement : public Statement {
public:
    std::string tableName;
    std::unique_ptr<Expression> whereClause;
    
    void accept(ASTVisitor& visitor) override;
};

// CREATE TABLE语句
class CreateTableStatement : public Statement {
public:
    std::string tableName;
    std::vector<std::unique_ptr<ColumnDefinition>> columns;
    std::vector<std::unique_ptr<TableConstraint>> constraints;
    
    void accept(ASTVisitor& visitor) override;
};

// 其他语句...
```

#### 2.3 表达式节点

```cpp
// 列引用
class ColumnReference : public Expression {
public:
    std::string tableName;
    std::string columnName;
    
    void accept(ASTVisitor& visitor) override;
};

// 字面量
class LiteralValue : public Expression {
public:
    enum class Type { INTEGER, FLOAT, STRING, BOOLEAN, NULL_VALUE };
    Type type;
    std::string value;
    
    void accept(ASTVisitor& visitor) override;
};

// 函数调用
class FunctionCall : public Expression {
public:
    std::string functionName;
    std::vector<std::unique_ptr<Expression>> arguments;
    bool distinct;
    
    void accept(ASTVisitor& visitor) override;
};

// 二元操作
class BinaryOperation : public Expression {
public:
    std::unique_ptr<Expression> left;
    std::string op;
    std::unique_ptr<Expression> right;
    
    void accept(ASTVisitor& visitor) override;
};

// 其他表达式...
```

### 3. 解析器实现

#### 3.1 类设计

```cpp
class Parser {
public:
    explicit Parser(const std::string& input);
    std::vector<std::unique_ptr<Statement>> parse();
    
private:
    Lexer lexer_;
    Token currentToken_;
    Token previousToken_;
    
    // 错误处理
    std::vector<ParseError> errors_;
    
    // 基础方法
    void advance();
    bool match(TokenType type);
    Token consume(TokenType type, const std::string& message);
    void error(const std::string& message);
    
    // 语句解析
    std::unique_ptr<Statement> parseStatement();
    std::unique_ptr<SelectStatement> parseSelectStatement();
    std::unique_ptr<InsertStatement> parseInsertStatement();
    std::unique_ptr<UpdateStatement> parseUpdateStatement();
    std::unique_ptr<DeleteStatement> parseDeleteStatement();
    std::unique_ptr<CreateTableStatement> parseCreateTableStatement();
    // 其他语句解析方法...
    
    // 表达式解析
    std::unique_ptr<Expression> parseExpression();
    std::unique_ptr<Expression> parseOrExpression();
    std::unique_ptr<Expression> parseAndExpression();
    std::unique_ptr<Expression> parseEqualityExpression();
    std::unique_ptr<Expression> parseComparisonExpression();
    std::unique_ptr<Expression> parseAdditiveExpression();
    std::unique_ptr<Expression> parseMultiplicativeExpression();
    std::unique_ptr<Expression> parseUnaryExpression();
    std::unique_ptr<Expression> parsePrimaryExpression();
    
    // 辅助解析
    std::vector<std::unique_ptr<Expression>> parseExpressionList();
    std::unique_ptr<TableReference> parseTableReference();
    std::unique_ptr<JoinClause> parseJoinClause();
    std::unique_ptr<OrderExpression> parseOrderExpression();
    // 其他辅助解析方法...
};
```

#### 3.2 错误处理

```cpp
class ParseError {
public:
    std::string message;
    int line;
    int column;
    std::string context;
    
    ParseError(const std::string& msg, int line, int column, const std::string& ctx)
        : message(msg), line(line), column(column), context(ctx) {}
};

class ErrorHandler {
public:
    static void reportError(const ParseError& error);
    static std::string formatError(const ParseError& error);
    static std::string getErrorContext(const std::string& input, int position, int contextSize = 20);
};
```

## 访问者模式

使用访问者模式实现AST的遍历和操作：

```cpp
class ASTVisitor {
public:
    virtual ~ASTVisitor() = default;
    
    // 语句访问
    virtual void visit(SelectStatement& stmt) = 0;
    virtual void visit(InsertStatement& stmt) = 0;
    virtual void visit(UpdateStatement& stmt) = 0;
    virtual void visit(DeleteStatement& stmt) = 0;
    virtual void visit(CreateTableStatement& stmt) = 0;
    // 其他语句访问方法...
    
    // 表达式访问
    virtual void visit(ColumnReference& expr) = 0;
    virtual void visit(LiteralValue& expr) = 0;
    virtual void visit(FunctionCall& expr) = 0;
    virtual void visit(BinaryOperation& expr) = 0;
    // 其他表达式访问方法...
};
```

## 性能优化

1. **内存池**：为AST节点分配使用内存池，减少内存分配开销
2. **字符串池**：共享标识符和字符串字面量，减少内存使用
3. **预分配**：预分配常用数据结构，如向量、映射等
4. **延迟计算**：对不立即需要的信息进行延迟计算

## 测试策略

1. **单元测试**：对词法解析器和语法解析器的各个组件进行单元测试
2. **集成测试**：对完整的SQL语句解析进行测试
3. **性能测试**：对比新旧解析器的性能
4. **错误处理测试**：测试各种错误情况的处理

## 兼容性

1. **API兼容**：保持现有API的兼容性，提供适配层
2. **功能兼容**：确保新解析器支持所有现有功能
3. **行为兼容**：保持对相同SQL语句的解析结果一致

## 总结

本设计文档提供了SQLCC解析器重构的详细设计方案，采用DFA词法解析器和递归下降语法解析器，提高了解析器的性能、可靠性和可维护性。通过模块化设计和清晰的AST结构，使解析器更易于扩展和维护。