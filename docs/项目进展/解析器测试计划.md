# SQLCC 解析器测试计划

## 概述

本文档详细描述了SQLCC项目SQL解析器的测试策略和计划，包括单元测试、集成测试、性能测试和错误处理测试等方面。

## 测试目标

1. **功能正确性**：确保解析器正确解析各种SQL语句
2. **错误处理**：验证解析器能够正确处理错误输入并提供有用的错误信息
3. **性能验证**：确保新解析器性能不低于现有解析器
4. **兼容性**：确保新解析器与现有系统兼容
5. **可维护性**：确保测试覆盖率高，便于未来维护

## 测试策略

### 1. 测试分层

#### 1.1 单元测试
- **词法解析器测试**：测试Token识别和生成
- **语法解析器测试**：测试AST节点构建
- **AST节点测试**：测试节点属性和方法

#### 1.2 集成测试
- **SQL语句解析测试**：测试完整SQL语句解析
- **复杂查询测试**：测试复杂SQL查询解析
- **多语句解析测试**：测试多语句脚本解析

#### 1.3 系统测试
- **端到端测试**：测试从SQL输入到AST输出的完整流程
- **性能测试**：测试解析器性能
- **兼容性测试**：测试与现有系统的兼容性

### 2. 测试工具

#### 2.1 测试框架
- **Google Test**：用于单元测试和集成测试
- **Google Benchmark**：用于性能测试
- **Valgrind**：用于内存泄漏检测

#### 2.2 测试辅助工具
- **测试数据生成器**：自动生成测试SQL语句
- **AST比较器**：比较两个AST是否等价
- **错误收集器**：收集和验证错误信息

## 词法解析器测试

### 1. Token识别测试

#### 1.1 关键字测试
```cpp
// 测试所有SQL关键字
TEST(LexerTest, RecognizeKeywords) {
    std::vector<std::pair<std::string, TokenType>> keywords = {
        {"SELECT", TokenType::K_SELECT},
        {"FROM", TokenType::K_FROM},
        {"WHERE", TokenType::K_WHERE},
        {"INSERT", TokenType::K_INSERT},
        // ... 其他关键字
    };
    
    for (const auto& [lexeme, type] : keywords) {
        Lexer lexer(lexeme);
        Token token = lexer.nextToken();
        EXPECT_EQ(token.getType(), type);
        EXPECT_EQ(token.getLexeme(), lexeme);
    }
}
```

#### 1.2 标识符测试
```cpp
TEST(LexerTest, RecognizeIdentifiers) {
    std::vector<std::string> identifiers = {
        "column1", "table_name", "func123", "_private", "$special"
    };
    
    for (const auto& id : identifiers) {
        Lexer lexer(id);
        Token token = lexer.nextToken();
        EXPECT_EQ(token.getType(), TokenType::IDENTIFIER);
        EXPECT_EQ(token.getLexeme(), id);
    }
}
```

#### 1.3 字面量测试
```cpp
TEST(LexerTest, RecognizeLiterals) {
    // 数字
    Lexer lexer1("123");
    Token token1 = lexer1.nextToken();
    EXPECT_EQ(token1.getType(), TokenType::NUMBER);
    EXPECT_EQ(token1.getLexeme(), "123");
    
    // 字符串
    Lexer lexer2("'hello world'");
    Token token2 = lexer2.nextToken();
    EXPECT_EQ(token2.getType(), TokenType::STRING);
    EXPECT_EQ(token2.getLexeme(), "'hello world'");
}
```

#### 1.4 操作符测试
```cpp
TEST(LexerTest, RecognizeOperators) {
    std::vector<std::pair<std::string, TokenType>> operators = {
        {"+", TokenType::PLUS},
        {"-", TokenType::MINUS},
        {"*", TokenType::MULTIPLY},
        {"/", TokenType::DIVIDE},
        {"=", TokenType::EQUAL},
        {"!=", TokenType::NOT_EQUAL},
        {"<", TokenType::LESS},
        {"<=", TokenType::LESS_EQUAL},
        {">", TokenType::GREATER},
        {">=", TokenType::GREATER_EQUAL},
    };
    
    for (const auto& [lexeme, type] : operators) {
        Lexer lexer(lexeme);
        Token token = lexer.nextToken();
        EXPECT_EQ(token.getType(), type);
        EXPECT_EQ(token.getLexeme(), lexeme);
    }
}
```

#### 1.5 标点符号测试
```cpp
TEST(LexerTest, RecognizePunctuation) {
    std::vector<std::pair<std::string, TokenType>> punctuations = {
        {"(", TokenType::LEFT_PAREN},
        {")", TokenType::RIGHT_PAREN},
        {",", TokenType::COMMA},
        {".", TokenType::DOT},
        {";", TokenType::SEMICOLON},
    };
    
    for (const auto& [lexeme, type] : punctuations) {
        Lexer lexer(lexeme);
        Token token = lexer.nextToken();
        EXPECT_EQ(token.getType(), type);
        EXPECT_EQ(token.getLexeme(), lexeme);
    }
}
```

### 2. 词法错误测试

```cpp
TEST(LexerTest, HandleInvalidCharacters) {
    Lexer lexer("SELECT @invalid");
    
    Token token1 = lexer.nextToken();
    EXPECT_EQ(token1.getType(), TokenType::K_SELECT);
    
    // 应该报告错误
    EXPECT_THROW(lexer.nextToken(), LexicalError);
}

TEST(LexerTest, HandleUnterminatedString) {
    Lexer lexer("'unterminated string");
    EXPECT_THROW(lexer.nextToken(), LexicalError);
}
```

## 语法解析器测试

### 1. 语句解析测试

#### 1.1 SELECT语句测试
```cpp
TEST(ParserTest, ParseSimpleSelectStatement) {
    Parser parser("SELECT id, name FROM users");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[0].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证SELECT列表
    ASSERT_EQ(selectStmt->selectList.size(), 2);
    auto col1 = dynamic_cast<ColumnReference*>(selectStmt->selectList[0].get());
    ASSERT_NE(col1, nullptr);
    EXPECT_EQ(col1->columnName, "id");
    
    auto col2 = dynamic_cast<ColumnReference*>(selectStmt->selectList[1].get());
    ASSERT_NE(col2, nullptr);
    EXPECT_EQ(col2->columnName, "name");
    
    // 验证FROM子句
    ASSERT_NE(selectStmt->fromClause, nullptr);
    EXPECT_EQ(selectStmt->fromClause->tableName, "users");
}

TEST(ParserTest, ParseSelectStatementWithWhereClause) {
    Parser parser("SELECT id FROM users WHERE age > 18");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[0].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证WHERE子句
    ASSERT_NE(selectStmt->whereClause, nullptr);
    auto binaryOp = dynamic_cast<BinaryOperation*>(selectStmt->whereClause.get());
    ASSERT_NE(binaryOp, nullptr);
    
    auto left = dynamic_cast<ColumnReference*>(binaryOp->left.get());
    ASSERT_NE(left, nullptr);
    EXPECT_EQ(left->columnName, "age");
    
    EXPECT_EQ(binaryOp->op, ">");
    
    auto right = dynamic_cast<LiteralValue*>(binaryOp->right.get());
    ASSERT_NE(right, nullptr);
    EXPECT_EQ(right->value, "18");
}

TEST(ParserTest, ParseSelectStatementWithGroupByClause) {
    Parser parser("SELECT department, COUNT(*) FROM employees GROUP BY department");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[0].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证GROUP BY子句
    ASSERT_EQ(selectStmt->groupByClause.size(), 1);
    auto groupByCol = dynamic_cast<ColumnReference*>(selectStmt->groupByClause[0].get());
    ASSERT_NE(groupByCol, nullptr);
    EXPECT_EQ(groupByCol->columnName, "department");
}

TEST(ParserTest, ParseSelectStatementWithFunctionCall) {
    Parser parser("SELECT COUNT(DISTINCT id) FROM users");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[0].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证函数调用
    ASSERT_EQ(selectStmt->selectList.size(), 1);
    auto funcCall = dynamic_cast<FunctionCall*>(selectStmt->selectList[0].get());
    ASSERT_NE(funcCall, nullptr);
    EXPECT_EQ(funcCall->functionName, "COUNT");
    EXPECT_TRUE(funcCall->distinct);
    
    // 验证函数参数
    ASSERT_EQ(funcCall->arguments.size(), 1);
    auto arg = dynamic_cast<ColumnReference*>(funcCall->arguments[0].get());
    ASSERT_NE(arg, nullptr);
    EXPECT_EQ(arg->columnName, "id");
}
```

#### 1.2 INSERT语句测试
```cpp
TEST(ParserTest, ParseInsertStatement) {
    Parser parser("INSERT INTO users (id, name, age) VALUES (1, 'John', 25)");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto insertStmt = dynamic_cast<InsertStatement*>(statements[0].get());
    ASSERT_NE(insertStmt, nullptr);
    
    EXPECT_EQ(insertStmt->tableName, "users");
    
    // 验证列名
    ASSERT_EQ(insertStmt->columns.size(), 3);
    EXPECT_EQ(insertStmt->columns[0], "id");
    EXPECT_EQ(insertStmt->columns[1], "name");
    EXPECT_EQ(insertStmt->columns[2], "age");
    
    // 验证值
    ASSERT_EQ(insertStmt->values.size(), 1);
    ASSERT_EQ(insertStmt->values[0].size(), 3);
    
    auto idVal = dynamic_cast<LiteralValue*>(insertStmt->values[0][0].get());
    ASSERT_NE(idVal, nullptr);
    EXPECT_EQ(idVal->value, "1");
    
    auto nameVal = dynamic_cast<LiteralValue*>(insertStmt->values[0][1].get());
    ASSERT_NE(nameVal, nullptr);
    EXPECT_EQ(nameVal->value, "'John'");
    
    auto ageVal = dynamic_cast<LiteralValue*>(insertStmt->values[0][2].get());
    ASSERT_NE(ageVal, nullptr);
    EXPECT_EQ(ageVal->value, "25");
}
```

#### 1.3 UPDATE语句测试
```cpp
TEST(ParserTest, ParseUpdateStatement) {
    Parser parser("UPDATE users SET age = 26 WHERE id = 1");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto updateStmt = dynamic_cast<UpdateStatement*>(statements[0].get());
    ASSERT_NE(updateStmt, nullptr);
    
    EXPECT_EQ(updateStmt->tableName, "users");
    
    // 验证SET子句
    ASSERT_EQ(updateStmt->setClause.size(), 1);
    EXPECT_EQ(updateStmt->setClause[0].first, "age");
    
    auto value = dynamic_cast<LiteralValue*>(updateStmt->setClause[0].second.get());
    ASSERT_NE(value, nullptr);
    EXPECT_EQ(value->value, "26");
    
    // 验证WHERE子句
    ASSERT_NE(updateStmt->whereClause, nullptr);
    auto binaryOp = dynamic_cast<BinaryOperation*>(updateStmt->whereClause.get());
    ASSERT_NE(binaryOp, nullptr);
    
    auto left = dynamic_cast<ColumnReference*>(binaryOp->left.get());
    ASSERT_NE(left, nullptr);
    EXPECT_EQ(left->columnName, "id");
    
    EXPECT_EQ(binaryOp->op, "=");
    
    auto right = dynamic_cast<LiteralValue*>(binaryOp->right.get());
    ASSERT_NE(right, nullptr);
    EXPECT_EQ(right->value, "1");
}
```

#### 1.4 DELETE语句测试
```cpp
TEST(ParserTest, ParseDeleteStatement) {
    Parser parser("DELETE FROM users WHERE id = 1");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto deleteStmt = dynamic_cast<DeleteStatement*>(statements[0].get());
    ASSERT_NE(deleteStmt, nullptr);
    
    EXPECT_EQ(deleteStmt->tableName, "users");
    
    // 验证WHERE子句
    ASSERT_NE(deleteStmt->whereClause, nullptr);
    auto binaryOp = dynamic_cast<BinaryOperation*>(deleteStmt->whereClause.get());
    ASSERT_NE(binaryOp, nullptr);
    
    auto left = dynamic_cast<ColumnReference*>(binaryOp->left.get());
    ASSERT_NE(left, nullptr);
    EXPECT_EQ(left->columnName, "id");
    
    EXPECT_EQ(binaryOp->op, "=");
    
    auto right = dynamic_cast<LiteralValue*>(binaryOp->right.get());
    ASSERT_NE(right, nullptr);
    EXPECT_EQ(right->value, "1");
}
```

#### 1.5 CREATE TABLE语句测试
```cpp
TEST(ParserTest, ParseCreateTableStatement) {
    Parser parser("CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50) NOT NULL)");
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto createTableStmt = dynamic_cast<CreateTableStatement*>(statements[0].get());
    ASSERT_NE(createTableStmt, nullptr);
    
    EXPECT_EQ(createTableStmt->tableName, "users");
    
    // 验证列定义
    ASSERT_EQ(createTableStmt->columns.size(), 2);
    
    auto idCol = createTableStmt->columns[0].get();
    EXPECT_EQ(idCol->name, "id");
    EXPECT_EQ(idCol->type, "INT");
    
    auto nameCol = createTableStmt->columns[1].get();
    EXPECT_EQ(nameCol->name, "name");
    EXPECT_EQ(nameCol->type, "VARCHAR(50)");
}
```

### 2. 表达式解析测试

#### 2.1 二元操作测试
```cpp
TEST(ParserTest, ParseBinaryOperations) {
    // 简单二元操作
    Parser parser1("a + b");
    auto statements1 = parser1.parse();
    auto expr1 = dynamic_cast<SelectStatement*>(statements1[0].get())->selectList[0].get();
    auto binaryOp1 = dynamic_cast<BinaryOperation*>(expr1);
    ASSERT_NE(binaryOp1, nullptr);
    EXPECT_EQ(binaryOp1->op, "+");
    
    // 操作符优先级
    Parser parser2("a + b * c");
    auto statements2 = parser2.parse();
    auto expr2 = dynamic_cast<SelectStatement*>(statements2[0].get())->selectList[0].get();
    auto binaryOp2 = dynamic_cast<BinaryOperation*>(expr2);
    ASSERT_NE(binaryOp2, nullptr);
    EXPECT_EQ(binaryOp2->op, "+");
    
    auto right = dynamic_cast<BinaryOperation*>(binaryOp2->right.get());
    ASSERT_NE(right, nullptr);
    EXPECT_EQ(right->op, "*");
    
    // 括号改变优先级
    Parser parser3("(a + b) * c");
    auto statements3 = parser3.parse();
    auto expr3 = dynamic_cast<SelectStatement*>(statements3[0].get())->selectList[0].get();
    auto binaryOp3 = dynamic_cast<BinaryOperation*>(expr3);
    ASSERT_NE(binaryOp3, nullptr);
    EXPECT_EQ(binaryOp3->op, "*");
    
    auto left = dynamic_cast<BinaryOperation*>(binaryOp3->left.get());
    ASSERT_NE(left, nullptr);
    EXPECT_EQ(left->op, "+");
}
```

#### 2.2 函数调用测试
```cpp
TEST(ParserTest, ParseFunctionCalls) {
    // 无参数函数
    Parser parser1("SELECT NOW()");
    auto statements1 = parser1.parse();
    auto expr1 = dynamic_cast<SelectStatement*>(statements1[0].get())->selectList[0].get();
    auto funcCall1 = dynamic_cast<FunctionCall*>(expr1);
    ASSERT_NE(funcCall1, nullptr);
    EXPECT_EQ(funcCall1->functionName, "NOW");
    EXPECT_EQ(funcCall1->arguments.size(), 0);
    
    // 单参数函数
    Parser parser2("SELECT COUNT(id)");
    auto statements2 = parser2.parse();
    auto expr2 = dynamic_cast<SelectStatement*>(statements2[0].get())->selectList[0].get();
    auto funcCall2 = dynamic_cast<FunctionCall*>(expr2);
    ASSERT_NE(funcCall2, nullptr);
    EXPECT_EQ(funcCall2->functionName, "COUNT");
    EXPECT_EQ(funcCall2->arguments.size(), 1);
    
    // 多参数函数
    Parser parser3("SELECT CONCAT(first_name, ' ', last_name)");
    auto statements3 = parser3.parse();
    auto expr3 = dynamic_cast<SelectStatement*>(statements3[0].get())->selectList[0].get();
    auto funcCall3 = dynamic_cast<FunctionCall*>(expr3);
    ASSERT_NE(funcCall3, nullptr);
    EXPECT_EQ(funcCall3->functionName, "CONCAT");
    EXPECT_EQ(funcCall3->arguments.size(), 3);
    
    // DISTINCT函数
    Parser parser4("SELECT COUNT(DISTINCT department)");
    auto statements4 = parser4.parse();
    auto expr4 = dynamic_cast<SelectStatement*>(statements4[0].get())->selectList[0].get();
    auto funcCall4 = dynamic_cast<FunctionCall*>(expr4);
    ASSERT_NE(funcCall4, nullptr);
    EXPECT_EQ(funcCall4->functionName, "COUNT");
    EXPECT_TRUE(funcCall4->distinct);
}
```

### 3. 错误处理测试

```cpp
TEST(ParserTest, HandleSyntaxErrors) {
    // 缺少FROM子句
    Parser parser1("SELECT id");
    EXPECT_THROW(parser1.parse(), ParseError);
    
    // 不匹配的括号
    Parser parser2("SELECT id FROM users WHERE (age > 18");
    EXPECT_THROW(parser2.parse(), ParseError);
    
    // 无效的操作符组合
    Parser parser3("SELECT id FROM users WHERE age > > 18");
    EXPECT_THROW(parser3.parse(), ParseError);
    
    // 缺少分号（如果需要）
    Parser parser4("SELECT id FROM users WHERE age > 18 INSERT INTO users VALUES (1, 'test')");
    EXPECT_THROW(parser4.parse(), ParseError);
}

TEST(ParserTest, ProvideDetailedErrorMessages) {
    Parser parser("SELECT id FROM users WHERE age >");
    try {
        parser.parse();
        FAIL() << "Expected ParseError exception";
    } catch (const ParseError& e) {
        // 验证错误信息包含行号和列号
        EXPECT_NE(e.message.find("line"), std::string::npos);
        EXPECT_NE(e.message.find("column"), std::string::npos);
        
        // 验证错误信息包含上下文
        EXPECT_NE(e.context.empty(), true);
    }
}
```

## 集成测试

### 1. 复杂查询测试

```cpp
TEST(IntegrationTest, ComplexSelectQuery) {
    std::string query = R"(
        SELECT u.id, u.name, COUNT(o.id) as order_count
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        WHERE u.age > 18 AND u.status = 'active'
        GROUP BY u.id, u.name
        HAVING COUNT(o.id) > 5
        ORDER BY order_count DESC
        LIMIT 10
        OFFSET 20
    )";
    
    Parser parser(query);
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 1);
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[0].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证SELECT列表
    ASSERT_EQ(selectStmt->selectList.size(), 3);
    
    // 验证FROM子句
    ASSERT_NE(selectStmt->fromClause, nullptr);
    
    // 验证JOIN
    ASSERT_NE(selectStmt->fromClause->joinClause, nullptr);
    
    // 验证WHERE子句
    ASSERT_NE(selectStmt->whereClause, nullptr);
    
    // 验证GROUP BY子句
    ASSERT_EQ(selectStmt->groupByClause.size(), 2);
    
    // 验证HAVING子句
    ASSERT_NE(selectStmt->havingClause, nullptr);
    
    // 验证ORDER BY子句
    ASSERT_EQ(selectStmt->orderByClause.size(), 1);
    
    // 验证LIMIT和OFFSET
    ASSERT_NE(selectStmt->limitClause, nullptr);
    ASSERT_NE(selectStmt->offsetClause, nullptr);
}
```

### 2. 多语句测试

```cpp
TEST(IntegrationTest, MultipleStatements) {
    std::string query = R"(
        CREATE TABLE users (
            id INT PRIMARY KEY,
            name VARCHAR(50) NOT NULL,
            age INT
        );
        
        INSERT INTO users (id, name, age) VALUES (1, 'John', 25);
        INSERT INTO users (id, name, age) VALUES (2, 'Jane', 30);
        
        SELECT * FROM users WHERE age > 25;
        
        DROP TABLE users;
    )";
    
    Parser parser(query);
    auto statements = parser.parse();
    
    ASSERT_EQ(statements.size(), 5);
    
    // 验证CREATE TABLE
    auto createTableStmt = dynamic_cast<CreateTableStatement*>(statements[0].get());
    ASSERT_NE(createTableStmt, nullptr);
    
    // 验证INSERT语句
    auto insertStmt1 = dynamic_cast<InsertStatement*>(statements[1].get());
    ASSERT_NE(insertStmt1, nullptr);
    
    auto insertStmt2 = dynamic_cast<InsertStatement*>(statements[2].get());
    ASSERT_NE(insertStmt2, nullptr);
    
    // 验证SELECT语句
    auto selectStmt = dynamic_cast<SelectStatement*>(statements[3].get());
    ASSERT_NE(selectStmt, nullptr);
    
    // 验证DROP TABLE
    auto dropTableStmt = dynamic_cast<DropTableStatement*>(statements[4].get());
    ASSERT_NE(dropTableStmt, nullptr);
}
```

## 性能测试

### 1. 解析速度测试

```cpp
static void BM_ParseSimpleSelect(benchmark::State& state) {
    std::string query = "SELECT id, name, age FROM users WHERE age > 18";
    
    for (auto _ : state) {
        Parser parser(query);
        auto statements = parser.parse();
        benchmark::DoNotOptimize(statements);
    }
}

static void BM_ParseComplexSelect(benchmark::State& state) {
    std::string query = R"(
        SELECT u.id, u.name, p.title, COUNT(c.id) as comment_count
        FROM users u
        JOIN posts p ON u.id = p.user_id
        LEFT JOIN comments c ON p.id = c.post_id
        WHERE u.created_at > '2020-01-01' AND p.status = 'published'
        GROUP BY u.id, u.name, p.title
        HAVING COUNT(c.id) > 10
        ORDER BY comment_count DESC, u.name ASC
        LIMIT 100
        OFFSET 50
    )";
    
    for (auto _ : state) {
        Parser parser(query);
        auto statements = parser.parse();
        benchmark::DoNotOptimize(statements);
    }
}

BENCHMARK(BM_ParseSimpleSelect);
BENCHMARK(BM_ParseComplexSelect);
```

### 2. 内存使用测试

```cpp
TEST(MemoryTest, MemoryUsage) {
    std::vector<std::string> queries = {
        "SELECT id FROM users",
        "SELECT id, name FROM users WHERE age > 18",
        "SELECT u.id, u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.id, u.name",
        // 更多查询...
    };
    
    for (const auto& query : queries) {
        // 使用Valgrind或其他内存检测工具运行
        // 验证没有内存泄漏
        Parser parser(query);
        auto statements = parser.parse();
        // 解析器析构时会释放AST
    }
}
```

## 测试数据

### 1. SQL语句样本

收集各种SQL语句作为测试数据，包括：
- 简单查询
- 复杂查询
- 边界情况
- 错误情况

### 2. AST参考输出

为每个有效SQL语句提供预期的AST结构，用于验证解析结果。

## 测试执行计划

### 阶段1：词法解析器测试
1. 实现Token识别测试
2. 实现词法错误处理测试
3. 验证测试覆盖率达到95%以上

### 阶段2：语法解析器测试
1. 实现各种语句解析测试
2. 实现表达式解析测试
3. 实现错误处理测试
4. 验证测试覆盖率达到95%以上

### 阶段3：集成测试
1. 实现复杂查询测试
2. 实现多语句测试
3. 验证端到端功能正确性

### 阶段4：性能测试
1. 实现解析速度测试
2. 实现内存使用测试
3. 与现有解析器性能对比

### 阶段5：回归测试
1. 运行所有现有测试
2. 确保新解析器与现有系统兼容
3. 修复发现的问题

## 测试覆盖率目标

1. **词法解析器**：95%以上
2. **语法解析器**：95%以上
3. **AST节点**：100%
4. **错误处理**：90%以上

## 测试自动化

1. **持续集成**：在代码提交时自动运行测试
2. **性能监控**：定期运行性能测试，监控性能变化
3. **覆盖率报告**：自动生成测试覆盖率报告
4. **回归测试**：自动运行回归测试，确保新功能不破坏现有功能

## 总结

本测试计划提供了全面的测试策略，确保SQLCC解析器重构后的质量和性能。通过单元测试、集成测试、性能测试和错误处理测试，我们可以验证解析器的功能正确性、性能和可靠性。测试自动化将确保持续的质量保证。