# SQLCC 数据库系统总体设计文档

## 1. 项目概述

### 1.1 项目背景
SQLCC (Simple Compact Course Computer) 是一个专为教学目的设计的轻量级关系型数据库管理系统，旨在提供一个完整且易于理解的数据库实现，帮助学习者掌握数据库系统的核心原理和实现技术。该项目通过简洁而全面的设计，涵盖了现代关系型数据库的关键组件和技术，同时保持代码的可读性和可维护性。

### 1.2 核心目标
- 提供一个完整的关系型数据库实现，包含存储引擎、SQL解析、索引、事务等核心组件
- 设计模块化架构，便于学习者理解各个组件的功能和交互
- 实现基本的ACID事务特性和并发控制机制
- 支持标准SQL语法的核心子集
- 提供良好的性能表现和稳定性
- 作为教学工具，辅助理解数据库内部实现原理

### 1.3 技术栈
- **开发语言**：C++
- **构建系统**：CMake
- **测试框架**：Google Test
- **通信协议**：自定义基于TCP/IP的协议
- **存储格式**：8KB定长页式存储
- **索引结构**：B+树

## 2. 系统架构

### 2.1 高层架构
SQLCC采用多层架构设计，将系统划分为清晰的功能层次，实现关注点分离和模块化设计。整体架构包括：

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              客户端层 (Client Layer)                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│  isql交互式客户端   │    API客户端(未来)    │   协议处理   │   网络通信   │ 连接管理  │
└───────────────────────────────────────┬──────────────────────────────────────────┘
                                        │ TCP/IP
┌───────────────────────────────────────▼──────────────────────────────────────────┐
│                              服务器层 (Server Layer)                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│ 网络处理 │ 协议解析 │ 请求路由 │ 会话管理 │ 认证授权 │ 连接池 │ 响应生成 │ 错误处理 │
└───────────────────────────────────────┬──────────────────────────────────────────┘
                                        │
┌───────────────────────────────────────▼──────────────────────────────────────────┐
│                              核心引擎层 (Core Engine Layer)                        │
├──────────────────────────────────────────────────────────────────────────────────┤
│  SQL解析器   │   查询执行器   │   事务管理器   │   锁管理器   │   配置管理器   │
└───────────────────────────────────────┬──────────────────────────────────────────┘
                                        │
┌───────────────────────────────────────▼──────────────────────────────────────────┐
│                              存储层 (Storage Layer)                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│    存储引擎    │    索引系统    │    缓冲池    │   磁盘管理器   │   WAL日志   │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 模块依赖关系

各模块之间的依赖关系如下：

```
客户端工具 → 网络层 → 协议层 → SQL解析器 → 查询执行器 → 事务管理器 → 存储引擎/索引系统
                                    ↓           ↓                ↓
                                  配置管理器    锁管理器         缓冲池/磁盘管理器/WAL日志
```

### 2.3 关键设计原则
- **模块化设计**：每个模块职责单一，接口清晰，便于独立开发和测试
- **分层架构**：通过明确的层次划分，实现关注点分离和功能抽象
- **接口导向**：模块间通过定义良好的接口进行交互，减少耦合
- **高内聚低耦合**：提高模块内部的内聚性，降低模块间的耦合度
- **可扩展性**：设计考虑未来功能扩展，如分布式支持、高级SQL特性等
- **性能优先**：核心模块设计注重性能，如缓冲池优化、索引设计等
- **可测试性**：所有模块设计支持单元测试和集成测试

## 3. 核心模块设计

### 3.1 存储引擎

#### 3.1.1 设计目标
实现高效的页式存储管理，支持定长和变长记录的存储，提供基本的文件空间管理功能。

#### 3.1.2 关键组件
- **页面管理器**：管理8KB定长页面的分配和回收
- **记录管理器**：处理定长和变长记录的存储格式
- **空间分配器**：管理空闲空间，减少碎片
- **表空间管理**：组织和管理表数据的物理存储

#### 3.1.3 数据结构
- **Page**：8KB定长页结构，包含页头和数据区域
- **Record**：记录结构，支持定长和变长格式
- **FileHeader**：文件头信息，包含元数据
- **FreeSpaceMap**：空闲空间映射表

#### 3.1.4 核心接口
- `Page* GetPage(page_id)`：获取指定页面
- `void FlushPage(page_id)`：将页面刷新到磁盘
- `page_id AllocatePage()`：分配新页面
- `void FreePage(page_id)`：释放页面
- `record_id InsertRecord(page_id, data)`：插入记录
- `void UpdateRecord(record_id, data)`：更新记录
- `void DeleteRecord(record_id)`：删除记录

### 3.2 索引系统

#### 3.2.1 设计目标
实现基于B+树的高效索引结构，支持点查询和范围查询，提升数据检索性能。

#### 3.2.2 关键组件
- **B+树节点**：内部节点和叶子节点的实现
- **索引管理器**：管理索引的创建、删除和维护
- **查询迭代器**：支持范围查询的遍历接口
- **键值编码器**：处理不同数据类型的键值编码

#### 3.2.3 数据结构
- **BTreeNode**：B+树节点基类
- **BTreeInternalNode**：内部节点实现
- **BTreeLeafNode**：叶子节点实现
- **BTreeCursor**：查询游标/迭代器

#### 3.2.4 核心接口
- `void CreateIndex(index_name, table_name, column_name)`：创建索引
- `void DropIndex(index_name)`：删除索引
- `record_id Lookup(key)`：根据键值查找记录
- `BTreeCursor RangeQuery(lower_bound, upper_bound)`：范围查询
- `void InsertKey(key, record_id)`：插入键值对
- `void DeleteKey(key)`：删除键值对

### 3.3 SQL解析器

#### 3.3.1 设计目标
将SQL文本解析为结构化的抽象语法树(AST)，为查询执行提供结构化表示。

#### 3.3.2 关键组件
- **词法分析器**：将SQL文本分解为标记(tokens)
- **语法分析器**：根据语法规则构建AST
- **语义分析器**：检查SQL语句的语义正确性
- **AST构建器**：构建和管理抽象语法树

#### 3.3.3 数据结构
- **Token**：词法标记
- **ASTNode**：AST节点基类
- **SelectNode**, **InsertNode**, etc.：各类SQL语句的AST节点
- **ExpressionNode**：表达式节点

#### 3.3.4 核心接口
- `AST* ParseSQL(sql_string)`：解析SQL语句
- `void ValidateAST(AST*)`：验证AST的语义正确性
- `std::string PrintAST(AST*)`：打印AST结构
- `void FreeAST(AST*)`：释放AST资源

### 3.4 事务管理器

#### 3.4.1 设计目标
实现ACID事务特性，提供并发控制和故障恢复机制，确保数据一致性。

#### 3.4.2 关键组件
- **事务管理器**：管理事务的开始、提交和回滚
- **锁管理器**：实现两阶段锁协议，支持共享锁和排他锁
- **死锁检测器**：检测和处理死锁情况
- **WAL管理器**：实现预写日志机制，支持故障恢复

#### 3.4.3 数据结构
- **Transaction**：事务对象，包含事务ID和状态
- **Lock**：锁对象，包含锁类型和资源ID
- **LockTable**：锁表，记录所有锁的状态
- **WaitGraph**：等待图，用于死锁检测
- **WALRecord**：预写日志记录

#### 3.4.4 核心接口
- `txn_id BeginTransaction()`：开始新事务
- `void CommitTransaction(txn_id)`：提交事务
- `void RollbackTransaction(txn_id)`：回滚事务
- `bool AcquireLock(txn_id, resource_id, lock_type)`：获取锁
- `void ReleaseLock(txn_id, resource_id)`：释放锁
- `void CreateSavepoint(txn_id, savepoint_name)`：创建保存点
- `void RollbackToSavepoint(txn_id, savepoint_name)`：回滚到保存点

### 3.5 查询执行器

#### 3.5.1 设计目标
执行SQL查询，生成查询计划，协调各模块完成数据操作。

#### 3.5.2 关键组件
- **查询计划生成器**：根据AST生成执行计划
- **计划执行器**：执行查询计划
- **操作符实现**：实现各种查询操作符（扫描、过滤、连接等）
- **结果集管理器**：管理查询结果集

#### 3.5.3 数据结构
- **ExecutionPlan**：执行计划
- **Operator**：操作符基类
- **ScanOperator**, **FilterOperator**, etc.：具体操作符实现
- **ResultSet**：查询结果集

#### 3.5.4 核心接口
- `ExecutionPlan* GeneratePlan(AST*)`：生成执行计划
- `ResultSet* ExecutePlan(ExecutionPlan*, txn_id)`：执行计划
- `void OptimizePlan(ExecutionPlan*)`：优化执行计划
- `void FreePlan(ExecutionPlan*)`：释放执行计划资源

### 3.6 缓冲池

#### 3.6.1 设计目标
实现内存缓冲机制，减少磁盘I/O，提高系统性能。

#### 3.6.2 关键组件
- **缓冲管理器**：管理页面缓存
- **替换策略**：实现LRU页面替换算法
- **同步机制**：处理多线程并发访问
- **脏页管理**：跟踪和刷新脏页

#### 3.6.3 数据结构
- **BufferFrame**：缓冲帧，包含页面数据和元数据
- **BufferPool**：缓冲池，管理所有缓冲帧
- **LRUList**：LRU列表，跟踪页面使用顺序

#### 3.6.4 核心接口
- `Page* PinPage(page_id)`：获取并固定页面
- `void UnpinPage(page_id, is_dirty)`：解除页面固定
- `void FlushAllDirtyPages()`：刷新所有脏页
- `void ResizeBufferPool(size)`：调整缓冲池大小
- `void ClearBufferPool()`：清空缓冲池

### 3.7 配置管理器

#### 3.7.1 设计目标
提供统一的配置管理功能，支持系统参数的加载、修改和持久化。

#### 3.7.2 关键组件
- **配置加载器**：从配置文件加载参数
- **配置验证器**：验证配置参数的合法性
- **配置访问器**：提供配置参数的访问接口
- **配置持久化**：将配置更改保存到文件

#### 3.7.3 数据结构
- **ConfigMap**：配置参数映射表
- **ConfigSchema**：配置参数模式定义

#### 3.7.4 核心接口
- `bool LoadConfig(config_file)`：加载配置文件
- `void SetConfig(key, value)`：设置配置参数
- `T GetConfig<T>(key, default_value)`：获取配置参数
- `bool SaveConfig()`：保存配置更改
- `void ValidateConfig()`：验证配置有效性

## 4. 数据流程

### 4.1 查询处理流程

```
SQL文本 → 词法分析 → 语法分析 → AST构建 → 语义分析 → 查询计划生成 → 计划优化 → 计划执行 → 结果返回
                                    ↓             ↓          ↓
                                 元数据检查      统计信息    索引选择
```

### 4.2 事务处理流程

#### 4.2.1 事务开始
1. 生成唯一事务ID
2. 创建事务上下文
3. 注册到事务管理器

#### 4.2.2 事务执行
1. 获取所需资源的锁
2. 执行数据操作
3. 记录WAL日志
4. 释放不再需要的锁

#### 4.2.3 事务提交
1. 获取提交锁
2. 写入提交日志
3. 释放所有资源锁
4. 标记事务完成
5. 清理事务上下文

#### 4.2.4 事务回滚
1. 获取回滚锁
2. 写入回滚日志
3. 根据日志撤销操作
4. 释放所有资源锁
5. 标记事务终止
6. 清理事务上下文

### 4.3 数据读写流程

#### 4.3.1 数据读取
1. 检查缓冲池
2. 缓冲未命中时从磁盘读取
3. 更新LRU状态
4. 返回页面数据

#### 4.3.2 数据写入
1. 获取页面的独占锁
2. 更新内存中的页面数据
3. 标记页面为脏
4. 适当时候通过WAL机制刷盘

## 5. 性能优化策略

### 5.1 缓冲池优化
- LRU替换策略优化
- 预取机制
- 批量I/O操作
- 多缓冲池分区

### 5.2 查询优化
- 索引选择优化
- 执行计划优化
- 谓词下推
- 连接顺序优化

### 5.3 并发控制优化
- 粒度锁优化
- 死锁预防算法改进
- 乐观并发控制（未来）
- 多版本并发控制（未来）

### 5.4 存储优化
- 压缩技术（未来）
- 分区表（未来）
- 列存储（未来）

## 6. 扩展性设计

### 6.1 功能扩展
- 插件系统设计
- 新数据类型支持
- 高级SQL特性实现路径

### 6.2 分布式扩展
- 分片架构设计
- 复制机制设计
- 分布式事务支持

### 6.3 接口扩展
- 外部API设计
- 驱动程序接口
- 监控和管理接口

## 7. 安全设计

### 7.1 访问控制
- 用户认证机制
- 权限管理系统
- 角色基础访问控制（未来）

### 7.2 数据安全
- 数据加密（未来）
- 审计日志
- 备份恢复机制

### 7.3 安全最佳实践
- 参数化查询防止SQL注入
- 输入验证
- 错误处理和信息泄露防护

## 8. 测试与验证

### 8.1 测试策略
- 单元测试覆盖所有关键模块
- 集成测试验证模块间交互
- 性能测试验证系统性能
- 压力测试验证系统稳定性
- 故障注入测试验证恢复机制

### 8.2 测试框架
- 基于Google Test的测试框架
- 自动化测试脚本
- 测试数据生成工具
- 覆盖率分析工具

## 9. 部署与运维

### 9.1 部署选项
- 单机部署
- Docker容器部署（未来）
- 分布式部署（未来）

### 9.2 配置管理
- 配置文件结构
- 环境变量支持
- 运行时配置更改

### 9.3 监控与日志
- 性能监控指标
- 日志级别和格式
- 诊断工具

## 10. 总结与展望

SQLCC数据库系统通过模块化、分层的架构设计，实现了一个完整的关系型数据库核心功能集。系统设计注重可理解性、可扩展性和性能，适合作为学习和教学工具，同时也为未来的功能扩展和性能优化提供了良好的基础。

未来的发展方向包括：增强SQL标准支持、实现多版本并发控制、添加分布式功能、优化性能和可靠性，以及提供更丰富的管理和监控工具。

---

*本文档描述了SQLCC数据库系统的总体设计，随着系统的不断发展和完善，文档将持续更新和优化。*