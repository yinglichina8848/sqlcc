# 实现代码模板

## 基本信息

- **版本号**: 1.0.3
- **阶段名称**: [阶段名称]
- **实现模块**: [模块名称]
- **实现日期**: [日期]
- **实现负责人**: [姓名]

## 代码结构

### 文件组织
```
src/
├── [模块名]/
│   ├── [类名].h          # 头文件
│   ├── [类名].cpp        # 实现文件
│   ├── [类名]_test.cpp   # 测试文件
│   └── CMakeLists.txt    # 构建配置
├── common/
│   ├── utils.h           # 工具函数
│   └── constants.h       # 常量定义
└── tests/
    ├── unit/             # 单元测试
    └── integration/      # 集成测试
```

### 命名规范
- **类名**: PascalCase，如 `SqlExecutor`
- **函数名**: camelCase，如 `executeQuery`
- **变量名**: snake_case，如 `max_buffer_size`
- **常量名**: UPPER_CASE，如 `MAX_CONNECTIONS`

## 头文件模板

### 基本结构
```cpp
#ifndef [MODULE_NAME]_[CLASS_NAME]_H
#define [MODULE_NAME]_[CLASS_NAME]_H

#include <vector>
#include <string>
#include <memory>

namespace sqlcc {

/**
 * @brief 类功能描述
 * 
 * 详细描述类的功能和使用方法
 */
class [ClassName] {
public:
    /**
     * @brief 构造函数
     * @param param1 参数1描述
     * @param param2 参数2描述
     */
    [ClassName]([参数类型] param1, [参数类型] param2);
    
    /**
     * @brief 析构函数
     */
    virtual ~[ClassName]();
    
    /**
     * @brief 主要方法描述
     * @param input 输入参数描述
     * @return 返回值描述
     * @throws 异常类型 异常描述
     */
    [返回类型] [methodName]([参数类型] input);
    
    /**
     * @brief 获取状态信息
     * @return 状态信息
     */
    [返回类型] getStatus() const;
    
private:
    // 私有成员变量
    [类型] member_variable_;
    
    // 私有方法
    void privateMethod_();
};

} // namespace sqlcc

#endif // [MODULE_NAME]_[CLASS_NAME]_H
```

## 实现文件模板

### 基本结构
```cpp
#include "[类名].h"
#include "common/utils.h"
#include <iostream>
#include <stdexcept>

namespace sqlcc {

// 构造函数实现
[ClassName]::[ClassName]([参数类型] param1, [参数类型] param2)
    : member_variable_(param1) {
    
    // 参数验证
    if (param1 <= 0) {
        throw std::invalid_argument("参数1必须大于0");
    }
    
    // 初始化逻辑
    initialize();
}

// 析构函数实现
[ClassName]::~[ClassName]() {
    // 清理资源
    cleanup();
}

// 主要方法实现
[返回类型] [ClassName]::[methodName]([参数类型] input) {
    // 输入验证
    if (input.empty()) {
        throw std::invalid_argument("输入不能为空");
    }
    
    try {
        // 业务逻辑实现
        [返回类型] result = processInput(input);
        
        // 结果验证
        validateResult(result);
        
        return result;
    } catch (const std::exception& e) {
        // 异常处理
        logger.error("方法执行失败: {}", e.what());
        throw;
    }
}

// 私有方法实现
void [ClassName]::privateMethod_() {
    // 实现细节
}

// 辅助函数实现
namespace {
    /**
     * @brief 内部辅助函数
     */
    void helperFunction() {
        // 实现
    }
}

} // namespace sqlcc
```

## 测试代码模板

### 单元测试模板
```cpp
#include <gtest/gtest.h>
#include "[类名].h"

namespace sqlcc {
namespace test {

class [ClassName]Test : public ::testing::Test {
protected:
    void SetUp() override {
        // 测试准备
        test_instance_ = std::make_unique<[ClassName]>(param1, param2);
    }
    
    void TearDown() override {
        // 测试清理
        test_instance_.reset();
    }
    
    std::unique_ptr<[ClassName]> test_instance_;
};

// 正常情况测试
TEST_F([ClassName]Test, NormalOperation) {
    // 准备测试数据
    [输入类型] input = createTestInput();
    
    // 执行测试
    [返回类型] result = test_instance_->[methodName](input);
    
    // 验证结果
    EXPECT_EQ(result.expected_value, actual_value);
    EXPECT_TRUE(result.is_valid());
}

// 边界条件测试
TEST_F([ClassName]Test, BoundaryConditions) {
    // 测试边界值
    [输入类型] boundary_input = createBoundaryInput();
    
    // 执行和验证
    EXPECT_NO_THROW(test_instance_->[methodName](boundary_input));
}

// 异常情况测试
TEST_F([ClassName]Test, ExceptionHandling) {
    // 准备异常输入
    [输入类型] invalid_input = createInvalidInput();
    
    // 验证异常抛出
    EXPECT_THROW(test_instance_->[methodName](invalid_input), std::exception);
}

// 性能测试
TEST_F([ClassName]Test, Performance) {
    const int iterations = 1000;
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < iterations; ++i) {
        test_instance_->[methodName](createTestInput());
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // 验证性能要求
    EXPECT_LT(duration.count(), max_allowed_time_ms);
}

} // namespace test
} // namespace sqlcc
```

## 构建配置模板

### CMakeLists.txt
```cmake
# 项目配置
cmake_minimum_required(VERSION 3.10)
project([模块名] VERSION 1.0.3)

# 编译器设置
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 依赖查找
find_package(GTest REQUIRED)

# 包含目录
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_SOURCE_DIR}/include
)

# 源文件
set(SOURCES
    [类名].cpp
    utils.cpp
)

# 头文件
set(HEADERS
    [类名].h
)

# 创建库
add_library([模块名] STATIC ${SOURCES} ${HEADERS})

# 链接库
target_link_libraries([模块名]
    PRIVATE
    GTest::gtest
    GTest::gtest_main
)

# 测试配置
if(BUILD_TESTING)
    # 测试源文件
    set(TEST_SOURCES
        [类名]_test.cpp
    )
    
    # 创建测试可执行文件
    add_executable([模块名]_test ${TEST_SOURCES})
    
    # 链接测试
    target_link_libraries([模块名]_test
        [模块名]
        GTest::gtest
        GTest::gtest_main
    )
    
    # 添加测试
    add_test(NAME [模块名]_test COMMAND [模块名]_test)
endif()
```

## 代码质量要求

### 代码规范
- **缩进**: 4个空格
- **行长度**: 不超过120字符
- **注释**: 函数和类必须有文档注释
- **命名**: 符合命名规范

### 错误处理
- **异常使用**: 合理使用异常处理错误
- **资源管理**: 使用RAII管理资源
- **输入验证**: 所有公共接口必须验证输入

### 性能优化
- **避免拷贝**: 使用引用和移动语义
- **内存管理**: 避免内存泄漏
- **算法选择**: 选择合适的数据结构和算法

## 测试要求

### 测试覆盖率
- **行覆盖率**: ≥ 80%
- **分支覆盖率**: ≥ 75%
- **函数覆盖率**: ≥ 85%

### 测试类型
- **单元测试**: 测试单个函数或类
- **集成测试**: 测试模块间交互
- **性能测试**: 测试性能指标

## 部署说明

### 编译要求
- **编译器**: g++ 7.0+ 或 clang++ 5.0+
- **构建工具**: CMake 3.10+
- **依赖库**: 列出所有依赖

### 运行要求
- **操作系统**: Linux/Windows/macOS
- **运行时库**: 列出运行时依赖
- **环境变量**: 必要的环境配置

## 维护说明

### 代码维护
- **代码审查**: 所有代码必须经过审查
- **版本控制**: 使用git进行版本管理
- **文档更新**: 代码变更必须更新文档

### 问题处理
- **Bug报告**: 使用issue跟踪系统
- **修复流程**: 制定标准的修复流程
- **回归测试**: 修复后必须进行回归测试

---

## 实现检查清单

- [ ] 代码符合命名规范
- [ ] 函数和类有完整的文档注释
- [ ] 所有公共接口有输入验证
- [ ] 异常处理完善
- [ ] 单元测试覆盖充分
- [ ] 性能测试通过
- [ ] 代码审查通过
- [ ] 文档更新完成

**实现人**: [姓名] - 日期: [日期]
**审查人**: [姓名] - 日期: [日期]