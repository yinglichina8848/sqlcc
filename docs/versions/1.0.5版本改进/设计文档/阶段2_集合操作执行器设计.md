# 阶段2：集合操作执行器设计文档

## 1. 设计概述

### 1.1 设计目标
本设计文档旨在定义集合操作执行器的架构、接口和实现方案，确保集合操作功能能够高效、稳定地集成到SqlCC的SQL执行引擎中。

### 1.2 设计原则
- **高性能**: 支持大数据量的集合操作
- **可扩展**: 易于添加新的集合操作类型
- **稳定性**: 完善的错误处理和资源管理
- **兼容性**: 与现有SQL执行流程无缝集成

### 1.3 技术约束
- 使用C++17标准
- 与现有AST节点结构兼容
- 支持多线程环境
- 内存使用可控

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   SQL Parser    │───▶│ SetOperationNode │───▶│ SqlExecutor     │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │                         │
                              ▼                         ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│ CompositeSelect │    │ SetOperation     │    │ ExecutionResult │
│   Statement     │    │   Executor       │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │                         │
                              ▼                         ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Subquery      │◀───│   Result Set     │───▶│   Final Result  │
│   Executor      │    │    Combiner      │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 2.2 核心组件

#### 2.2.1 SetOperationExecutor（主执行器）
- 负责协调整个集合操作执行流程
- 管理子查询执行和结果合并
- 处理错误和异常情况

#### 2.2.2 ResultSetCombiner（结果集合并器）
- 实现具体的集合操作算法
- 支持流式处理避免内存爆炸
- 提供性能优化机制

#### 2.2.3 MemoryManager（内存管理器）
- 控制集合操作的内存使用
- 提供内存使用监控和限制
- 支持大结果集的分页处理

## 3. 详细设计

### 3.1 类设计

#### 3.1.1 SetOperationExecutor类

```cpp
class SetOperationExecutor {
public:
    // 构造函数
    explicit SetOperationExecutor(std::shared_ptr<SqlExecutor> sql_executor);
    
    // 执行集合操作
    ExecutionResult execute(const SetOperationNode& operation);
    
    // 设置内存限制
    void set_memory_limit(size_t limit_bytes);
    
    // 获取执行统计信息
    ExecutionStats get_stats() const;
    
private:
    // 执行UNION操作
    ExecutionResult execute_union(const SetOperationNode& operation);
    
    // 执行INTERSECT操作
    ExecutionResult execute_intersect(const SetOperationNode& operation);
    
    // 执行EXCEPT操作
    ExecutionResult execute_except(const SetOperationNode& operation);
    
    // 执行子查询
    ExecutionResult execute_subquery(const std::unique_ptr<SelectStatement>& subquery);
    
    // 验证结果集兼容性
    bool validate_result_compatibility(const ExecutionResult& left, 
                                      const ExecutionResult& right);
    
    std::shared_ptr<SqlExecutor> sql_executor_;
    size_t memory_limit_;
    ExecutionStats stats_;
};
```

#### 3.1.2 ResultSetCombiner类

```cpp
class ResultSetCombiner {
public:
    // 合并两个结果集（UNION ALL）
    static ExecutionResult union_all(const ExecutionResult& left, 
                                    const ExecutionResult& right);
    
    // 合并两个结果集并去重（UNION）
    static ExecutionResult union_distinct(const ExecutionResult& left, 
                                         const ExecutionResult& right);
    
    // 求交集（INTERSECT）
    static ExecutionResult intersect(const ExecutionResult& left, 
                                    const ExecutionResult& right, 
                                    bool all);
    
    // 求差集（EXCEPT）
    static ExecutionResult except(const ExecutionResult& left, 
                                 const ExecutionResult& right, 
                                 bool all);
    
    // 流式处理支持
    class StreamingProcessor {
    public:
        virtual ~StreamingProcessor() = default;
        virtual void process_row(const Row& row) = 0;
        virtual ExecutionResult get_result() = 0;
    };
    
    // 创建流式处理器
    static std::unique_ptr<StreamingProcessor> create_streaming_processor(
        SetOperationType operation_type, bool all);
};
```

### 3.2 接口设计

#### 3.2.1 执行接口

```cpp
// 主要的执行接口
ExecutionResult SetOperationExecutor::execute(const SetOperationNode& operation) {
    // 1. 验证操作有效性
    if (!operation.is_valid()) {
        throw InvalidOperationException("Invalid set operation");
    }
    
    // 2. 执行左操作数
    auto left_result = execute_subquery(operation.get_left_operand());
    
    // 3. 执行右操作数
    auto right_result = execute_subquery(operation.get_right_operand());
    
    // 4. 验证结果集兼容性
    if (!validate_result_compatibility(left_result, right_result)) {
        throw IncompatibleResultException("Incompatible result sets");
    }
    
    // 5. 根据操作类型执行相应的集合操作
    switch (operation.get_operation_type()) {
        case SetOperationType::UNION:
            return execute_union(operation);
        case SetOperationType::INTERSECT:
            return execute_intersect(operation);
        case SetOperationType::EXCEPT:
            return execute_except(operation);
        default:
            throw UnsupportedOperationException("Unsupported set operation");
    }
}
```

#### 3.2.2 流式处理接口

```cpp
// 流式UNION处理器
class UnionStreamingProcessor : public ResultSetCombiner::StreamingProcessor {
public:
    UnionStreamingProcessor(bool distinct) : distinct_(distinct) {}
    
    void process_row(const Row& row) override {
        if (distinct_) {
            // 去重逻辑
            auto key = generate_row_key(row);
            if (seen_rows_.insert(key).second) {
                result_.add_row(row);
            }
        } else {
            // 不去重，直接添加
            result_.add_row(row);
        }
    }
    
    ExecutionResult get_result() override {
        return std::move(result_);
    }
    
private:
    bool distinct_;
    ExecutionResult result_;
    std::unordered_set<RowKey> seen_rows_;
    
    RowKey generate_row_key(const Row& row) {
        // 生成行的唯一标识符用于去重
        // 实现细节...
    }
};
```

### 3.3 数据结构设计

#### 3.3.1 执行结果结构

```cpp
struct ExecutionResult {
    // 结果集数据
    std::vector<Row> rows;
    
    // 元数据
    std::vector<ColumnMeta> column_metadata;
    
    // 执行统计
    ExecutionStats stats;
    
    // 错误信息
    std::optional<std::string> error_message;
    
    // 方法
    void add_row(const Row& row);
    size_t row_count() const;
    bool is_empty() const;
    bool has_error() const;
};

struct ExecutionStats {
    size_t rows_processed;
    size_t memory_used;
    std::chrono::milliseconds execution_time;
    std::chrono::milliseconds io_time;
};
```

#### 3.3.2 行键结构（用于去重）

```cpp
struct RowKey {
    std::vector<Value> values;
    
    bool operator==(const RowKey& other) const {
        return values == other.values;
    }
    
    struct Hash {
        size_t operator()(const RowKey& key) const {
            size_t hash = 0;
            for (const auto& value : key.values) {
                hash_combine(hash, value.hash());
            }
            return hash;
        }
    };
};
```

## 4. 算法设计

### 4.1 UNION算法

#### 4.1.1 UNION ALL（简单合并）
```
算法: UNION_ALL
输入: 左结果集L，右结果集R
输出: 合并后的结果集

1. 创建空结果集Result
2. 将L中的所有行添加到Result
3. 将R中的所有行添加到Result
4. 返回Result
```

#### 4.1.2 UNION DISTINCT（去重合并）
```
算法: UNION_DISTINCT
输入: 左结果集L，右结果集R
输出: 去重合并后的结果集

1. 创建空结果集Result
2. 创建哈希表Seen用于记录已见过的行
3. 遍历L中的每一行:
   a. 生成行键Key
   b. 如果Key不在Seen中:
      i. 将行添加到Result
      ii. 将Key添加到Seen
4. 遍历R中的每一行:
   a. 生成行键Key
   b. 如果Key不在Seen中:
      i. 将行添加到Result
      ii. 将Key添加到Seen
5. 返回Result
```

### 4.2 INTERSECT算法

#### 4.2.1 INTERSECT ALL（保留重复）
```
算法: INTERSECT_ALL
输入: 左结果集L，右结果集R
输出: 交集结果集（保留重复）

1. 创建空结果集Result
2. 创建计数器CountMap记录R中每行的出现次数
3. 遍历R，统计每行的出现次数
4. 遍历L中的每一行:
   a. 生成行键Key
   b. 如果Key在CountMap中且计数>0:
      i. 将行添加到Result
      ii. CountMap[Key]减1
5. 返回Result
```

### 4.3 EXCEPT算法

#### 4.3.1 EXCEPT ALL（保留重复）
```
算法: EXCEPT_ALL
输入: 左结果集L，右结果集R
输出: 差集结果集（保留重复）

1. 创建空结果集Result
2. 创建计数器CountMap记录R中每行的出现次数
3. 遍历R，统计每行的出现次数
4. 遍历L中的每一行:
   a. 生成行键Key
   b. 如果Key不在CountMap中或CountMap[Key] == 0:
      i. 将行添加到Result
   c. 否则:
      i. CountMap[Key]减1
5. 返回Result
```

## 5. 性能优化设计

### 5.1 内存优化

#### 5.1.1 流式处理
- 支持逐行处理，避免加载整个结果集到内存
- 使用迭代器模式遍历结果集
- 实现内存使用监控和限制

#### 5.1.2 分页处理
- 大结果集自动分页处理
- 支持结果集的分块合并
- 提供内存使用预警机制

### 5.2 算法优化

#### 5.2.1 哈希表优化
- 使用高效的哈希函数
- 动态调整哈希表大小
- 支持自定义哈希策略

#### 5.2.2 并行处理
- 支持子查询并行执行
- 使用线程池管理执行任务
- 实现结果集的并行合并

### 5.3 缓存优化

#### 5.3.1 查询结果缓存
- 缓存频繁执行的子查询结果
- 支持缓存失效策略
- 提供缓存统计和监控

## 6. 错误处理设计

### 6.1 异常类型定义

```cpp
// 集合操作专用异常
class SetOperationException : public std::runtime_error {
public:
    explicit SetOperationException(const std::string& message)
        : std::runtime_error(message) {}
};

class IncompatibleResultException : public SetOperationException {
    // 结果集不兼容异常
};

class MemoryLimitExceededException : public SetOperationException {
    // 内存限制超出异常
};

class InvalidOperationException : public SetOperationException {
    // 无效操作异常
};
```

### 6.2 错误处理策略

#### 6.2.1 预防性检查
- 操作前验证参数有效性
- 检查内存使用限制
- 验证结果集兼容性

#### 6.2.2 恢复机制
- 内存超出时自动清理
- 支持操作回滚
- 提供详细的错误信息

## 7. 测试设计

### 7.1 单元测试设计

#### 7.1.1 测试用例分类
- **功能测试**: 验证各种集合操作的正确性
- **边界测试**: 测试空结果集、单行结果集等边界情况
- **性能测试**: 测试大数据量下的性能表现
- **错误测试**: 测试异常情况处理

#### 7.1.2 测试数据设计
- 使用Mock对象模拟子查询执行
- 创建各种规模和大小的测试数据集
- 设计覆盖所有代码路径的测试用例

### 7.2 集成测试设计

#### 7.2.1 端到端测试
- 测试完整的SQL解析和执行流程
- 验证与现有功能的兼容性
- 测试真实场景下的性能表现

#### 7.2.2 性能基准测试
- 建立性能基准线
- 监控内存使用和响应时间
- 对比不同算法实现的性能差异

## 8. 部署和配置

### 8.1 配置参数

```cpp
struct SetOperationConfig {
    size_t memory_limit = 1024 * 1024 * 1024; // 1GB默认内存限制
    size_t streaming_threshold = 10000; // 流式处理阈值
    bool enable_parallel_execution = true; // 启用并行执行
    size_t max_parallel_threads = 4; // 最大并行线程数
};
```

### 8.2 集成方式

#### 8.2.1 代码集成
- 在SqlExecutor中注册集合操作处理器
- 更新SQL执行流程支持复合SELECT语句
- 保持向后兼容性

#### 8.2.2 配置集成
- 提供默认配置参数
- 支持运行时配置调整
- 集成到系统配置管理

## 9. 总结

本设计文档详细定义了集合操作执行器的架构、接口和实现方案。通过采用模块化设计、流式处理和性能优化策略，确保了集合操作功能的高效性和稳定性。

设计遵循了SqlCC项目的技术规范和架构原则，为后续的实现和测试工作提供了明确的技术指导。