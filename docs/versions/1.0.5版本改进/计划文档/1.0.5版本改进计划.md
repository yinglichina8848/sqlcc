# SqlCC v1.0.5 改进计划

## 1. 概述

基于v1.0.5版本的深度评估和当前实现状态，本改进计划聚焦于四个关键领域：
1. **集合操作功能实现**（已完成基础架构）
2. **SQL高级功能增强**
3. **事务处理能力完善**
4. **性能优化和代码质量提升**

本计划按照优先级分为四个阶段：紧急修复、短期改进、中期发展和长期规划。

## 2. 紧急修复（已完成）

### 2.1 集合操作基础架构实现（已完成）

**状态**: ✅ **已实现**

#### 2.1.1 Token类扩展
**实现状态**: ✅ **已完成**
- 扩展Token定义，添加集合操作关键字(UNION/INTERSECT/EXCEPT/ALL)
- 更新Token类的getTypeName方法支持新关键字

#### 2.1.2 Lexer扩展
**实现状态**: ✅ **已完成**
- 更新Lexer的关键字映射支持集合操作
- 支持集合操作关键字的识别和解析

#### 2.1.3 AST节点类设计
**实现状态**: ✅ **已完成**
- 设计集合操作AST节点类结构
- 实现SetOperationNode和CompositeSelectStatement类

#### 2.1.4 Parser解析器扩展
**实现状态**: ✅ **已完成**
- 扩展Parser解析器支持集合操作语法
- 实现parseCompositeSelectStatement和parseSetOperation方法

#### 2.1.5 Visitor模式支持
**实现状态**: ✅ **已完成**
- 更新NodeVisitor接口支持新节点类型
- 扩展AdvancedNodeVisitor和AdvancedNodePrinter类

**工作量**: 已完成

### 2.2 编译错误修复（已完成）

**状态**: ✅ **已实现**

**修复内容**:
- ✅ 修复isSetOperation()方法未声明问题
- ✅ 修复set_operation_node.cpp未包含在编译中的链接错误
- ✅ 修复AdvancedNodeVisitor未实现新接口的编译错误
- ✅ 修复AdvancedNodePrinter未实现新接口的编译错误
- ✅ 修复头文件包含问题导致的不完全类型错误

**实现状态**:
- ✅ 所有编译错误已解决
- ✅ 项目成功编译通过
- ✅ 集合操作基础架构完整可用

**工作量**: 已完成

## 3. 短期改进（1-2周）

### 3.1 集合操作功能完善（P1）

**优先级**: 🟠 **高**

#### 3.1.1 集合操作执行器实现

**实现内容**:
```cpp
// 集合操作执行器
class SetOperationExecutor {
public:
    ExecutionResult execute(const SetOperationNode& operation) {
        // 执行左操作数
        auto leftResult = executeSelect(*operation.getLeftOperand());
        
        // 执行右操作数
        auto rightResult = executeSelect(*operation.getRightOperand());
        
        // 根据操作类型合并结果
        switch (operation.getOperationType()) {
            case SetOperationType::UNION:
                return executeUnion(leftResult, rightResult, operation.isAll());
            case SetOperationType::INTERSECT:
                return executeIntersect(leftResult, rightResult, operation.isAll());
            case SetOperationType::EXCEPT:
                return executeExcept(leftResult, rightResult, operation.isAll());
            default:
                throw std::runtime_error("Unsupported set operation");
        }
    }
    
private:
    ExecutionResult executeUnion(const ExecutionResult& left, 
                                const ExecutionResult& right, bool all) {
        // UNION操作实现
        if (all) {
            // UNION ALL：保留重复记录
            return unionAll(left, right);
        } else {
            // UNION：去除重复记录
            return unionDistinct(left, right);
        }
    }
    
    // INTERSECT和EXCEPT实现...
};
```

**工作量估算**: 3-4人日

#### 3.1.2 集合操作单元测试

**实现内容**:
```cpp
// 集合操作单元测试
TEST(SetOperationTest, UnionBasic) {
    Parser parser;
    auto stmt = parser.parse("SELECT id FROM table1 UNION SELECT id FROM table2");
    
    ASSERT_NE(stmt, nullptr);
    ASSERT_TRUE(dynamic_cast<CompositeSelectStatement*>(stmt.get()));
    
    // 执行测试...
}

TEST(SetOperationTest, IntersectWithAll) {
    Parser parser;
    auto stmt = parser.parse("SELECT name FROM users INTERSECT ALL SELECT name FROM employees");
    
    ASSERT_NE(stmt, nullptr);
    // 验证解析结果...
}
```

**工作量估算**: 2-3人日

### 3.2 窗口函数支持（P1）

**优先级**: 🟠 **高**

#### 3.2.1 窗口函数AST节点

**实现内容**:
```cpp
// 窗口函数AST节点
class WindowFunctionNode : public ExpressionNode {
public:
    WindowFunctionNode(const std::string& function_name,
                      std::vector<std::unique_ptr<ExpressionNode>> args,
                      std::unique_ptr<WindowSpecificationNode> window_spec)
        : function_name_(function_name), args_(std::move(args)),
          window_spec_(std::move(window_spec)) {}
    
    // 实现访问者模式接口
    void accept(ASTVisitor& visitor) override {
        visitor.visit(*this);
    }
    
private:
    std::string function_name_;
    std::vector<std::unique_ptr<ExpressionNode>> args_;
    std::unique_ptr<WindowSpecificationNode> window_spec_;
};
```

**工作量估算**: 2-3人日

## 4. 中期发展（2-4周）

### 4.1 事务隔离级别增强（P2）

**优先级**: 🟡 **中**

#### 4.1.1 READ UNCOMMITTED实现

**实现内容**:
```cpp
// 事务管理器隔离级别支持扩展
class TransactionManager {
public:
    // 设置隔离级别
    void set_isolation_level(TransactionId txn_id, IsolationLevel level) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = transactions_.find(txn_id);
        if (it != transactions_.end()) {
            it->second.isolation_level = level;
        }
    }
    
    // READ UNCOMMITTED读取逻辑
    Value read_uncommitted(TransactionId txn_id, const std::string& resource) {
        // 允许读取未提交的数据
        // 不获取任何锁，直接返回最新值
        return storage_engine_->read_latest(resource);
    }
};
```

**工作量估算**: 2-3人日

### 4.2 性能优化（P2）

**优先级**: 🟡 **中**

#### 4.2.1 锁粒度优化

**实现内容**:
```cpp
// 细粒度锁管理器
class FineGrainedLockManager {
public:
    // 行级锁支持
    bool acquire_row_lock(TransactionId txn_id, 
                         const std::string& table_name,
                         int64_t row_id, 
                         LockType lock_type) {
        std::string resource_key = table_name + ":" + std::to_string(row_id);
        
        std::unique_lock<std::mutex> lock(global_mutex_);
        
        // 检查锁兼容性
        if (is_lock_compatible(resource_key, txn_id, lock_type)) {
            // 授予锁
            lock_table_[resource_key].push_back({txn_id, lock_type});
            return true;
        }
        
        return false;
    }
};
```

**工作量估算**: 3-4人日

## 5. 长期规划（1-3个月）

### 5.1 查询优化器增强（P3）

**优先级**: 🔵 **低**

#### 5.1.1 基于成本的优化

**实现内容**:
```cpp
// 成本估算器
class CostEstimator {
public:
    struct Cost {
        double cpu_cost;
        double io_cost;
        double memory_cost;
        double total_cost() const { return cpu_cost + io_cost + memory_cost; }
    };
    
    // 估算查询计划成本
    Cost estimate_cost(const QueryPlan& plan) {
        Cost total_cost{0, 0, 0};
        
        for (const auto& node : plan.nodes()) {
            switch (node.type()) {
                case PlanNodeType::SCAN:
                    total_cost += estimate_scan_cost(node);
                    break;
                case PlanNodeType::JOIN:
                    total_cost += estimate_join_cost(node);
                    break;
                // 其他节点类型...
            }
        }
        
        return total_cost;
    }
};
```

**工作量估算**: 4-5人日

## 6. 实施路线图

### 6.1 第一阶段：集合操作基础架构（已完成）
**状态**: ✅ **已完成**
- ✅ 完成Token和Lexer的扩展
- ✅ 实现SetOperationNode和CompositeSelectStatement类
- ✅ 扩展Parser解析器支持集合操作语法
- ✅ 修复所有编译错误，项目成功编译

### 6.2 第二阶段：集合操作功能完善（进行中）
**状态**: 🔄 **进行中**
- 🔄 实现集合操作执行器
- 🔄 编写集合操作单元测试
- 🔄 集成到SQL执行引擎

### 6.3 第三阶段：SQL高级功能（待开始）
**状态**: 🔄 **待开始**
- 🔄 实现窗口函数支持
- 🔄 增强事务隔离级别
- 🔄 优化锁管理和并发控制

### 6.4 第四阶段：性能优化（长期规划）
**状态**: 🔄 **长期规划**
- 🔄 实现细粒度锁和MVCC
- 🔄 优化缓冲池和I/O性能
- 🔄 增强查询优化器

### 6.5 当前进展总结
- **已完成**: 集合操作基础架构、编译错误修复
- **进行中**: 集合操作执行器实现、单元测试编写
- **待开始**: SQL高级功能、性能优化

## 7. 风险评估和缓解措施

### 7.1 技术风险

#### 7.1.1 兼容性风险
**风险描述**: 新功能可能破坏现有API和功能
**缓解措施**: 
- 充分测试回归测试用例
- 采用渐进式实现策略
- 保持向后兼容性

#### 7.1.2 性能风险
**风险描述**: 集合操作可能引入性能瓶颈
**缓解措施**:
- 进行性能基准测试
- 优化结果集合并算法
- 监控内存使用情况

### 7.2 资源风险

#### 7.2.1 开发资源不足
**风险描述**: 复杂功能实现需要较多开发时间
**缓解措施**:
- 优先实现核心功能
- 采用模块化开发方式
- 合理分配开发任务

## 8. 成功标准

### 8.1 功能完整性
- ✅ 集合操作基础架构完整实现
- 🔄 集合操作执行器功能完善（进行中）
- 🔄 窗口函数语法支持（待实现）
- 🔄 多事务隔离级别支持（待实现）

### 8.2 性能指标
- 📊 集合操作查询响应时间 < 50ms
- 📊 UNION操作内存使用 < 100MB（10000条记录）
- 📊 并发集合操作支持 > 10个并发查询

### 8.3 代码质量
- 📊 集合操作模块测试覆盖率 > 80%
- 📊 所有关键算法都有详细文档
- 📊 通过代码审查和静态分析

### 8.4 当前实现状态总结
- ✅ **已完成**: 集合操作基础架构、编译错误修复
- 🔄 **进行中**: 集合操作执行器实现、单元测试编写
- 🔄 **待实现**: SQL高级功能、性能优化

## 9. 总结

本改进计划已根据SqlCC v1.0.5版本的当前实现状态进行了全面更新。**集合操作基础架构阶段的主要任务已经完成**，包括：

### 已完成的核心功能
- ✅ **Token和Lexer扩展**: 支持UNION、INTERSECT、EXCEPT、ALL关键字
- ✅ **AST节点类实现**: SetOperationNode和CompositeSelectStatement完整实现
- ✅ **Parser解析器扩展**: 支持集合操作语法解析
- ✅ **Visitor模式支持**: 更新所有相关Visitor类
- ✅ **编译错误修复**: 解决所有编译问题，项目成功构建

### 当前状态评估
- **功能完整性**: 集合操作基础架构已达到可用标准
- **代码质量**: 核心模块实现稳定，架构设计合理
- **测试覆盖**: 基础架构已具备，执行器测试待完善

### 未来发展方向
本计划为SqlCC的持续演进提供了清晰的技术路线图，后续将重点推进：
- **集合操作功能完善**: 执行器实现、单元测试、性能优化
- **SQL高级功能实现**: 窗口函数、CTE等现代SQL特性
- **事务隔离级别增强**: READ UNCOMMITTED、REPEATABLE READ等高级隔离级别
- **性能优化**: 锁粒度优化、缓冲池优化、查询优化器增强

通过有序实施后续改进计划，SqlCC将进一步提升其企业级应用能力和系统可扩展性。