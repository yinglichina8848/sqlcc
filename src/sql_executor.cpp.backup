#include "sql_executor.h"
#include "sql_parser/parser.h"
#include <algorithm>
#include <cctype>
#include <iomanip>
#include <iostream>
#include <sstream>

namespace sqlcc {

// =====================================
// 构造函数实现
// =====================================

SqlExecutor::SqlExecutor() : current_database_("sqlcc") {
  index_executor_ =
      std::unique_ptr<IndexManager>(nullptr); // TODO: 从StorageEngine获取
  transaction_manager_ =
      std::unique_ptr<TransactionManager>(nullptr); // TODO: 初始化事务管理器
}

SqlExecutor::SqlExecutor(StorageEngine &storage_engine)
    : storage_engine_(&storage_engine), current_database_("sqlcc") {
  index_executor_ = std::unique_ptr<IndexManager>(
      nullptr); // TODO: 从StorageEngine获取index manager
  transaction_manager_ =
      std::unique_ptr<TransactionManager>(nullptr); // TODO: 初始化事务管理器
}

// =====================================
// 主要接口方法实现
// =====================================

std::string SqlExecutor::Execute(const std::string &sql) {
  // 清理上一次错误
  SetError("");

  if (sql.empty()) {
    return "";
  }

  // 移除开头和结尾的空白字符
  std::string trimmed_sql = sql;
  TrimString(trimmed_sql);

  if (trimmed_sql.empty()) {
    return "";
  }

  try {
    // 解析SQL语句
    SqlParser parser;
    auto statements = parser.Parse(trimmed_sql);

    if (statements.empty()) {
      return "ERROR: Failed to parse SQL statement\n";
    }

    // 目前只执行第一条语句
    const auto &stmt = statements[0];
    return ExecuteStatement(stmt);

  } catch (const std::exception &e) {
    SetError(e.what());
    return "ERROR: " + std::string(e.what()) + "\n";
  }
}

std::string SqlExecutor::ExecuteFile(const std::string &file_path) {
  SetError("");
  // TODO: 实现文件执行逻辑
  return "ERROR: ExecuteFile not implemented\n";
}

// =====================================
// 语句分发执行
// =====================================

std::string
SqlExecutor::ExecuteStatement(const sql_parser::StatementPtr &stmt) {
  std::lock_guard<std::mutex> lock(execution_mutex_);

  switch (stmt->getType()) {
  case sql_parser::Statement::Type::CREATE:
    return ExecuteCreate(
        dynamic_cast<const sql_parser::CreateStatement &>(*stmt));

  case sql_parser::Statement::Type::DROP:
    return ExecuteDrop(dynamic_cast<const sql_parser::DropStatement &>(*stmt));

  case sql_parser::Statement::Type::ALTER:
    return ExecuteAlter(
        dynamic_cast<const sql_parser::AlterStatement &>(*stmt));

  case sql_parser::Statement::Type::INSERT:
    return ExecuteInsert(
        dynamic_cast<const sql_parser::InsertStatement &>(*stmt));

  case sql_parser::Statement::Type::UPDATE:
    return ExecuteUpdate(
        dynamic_cast<const sql_parser::UpdateStatement &>(*stmt));

  case sql_parser::Statement::Type::DELETE:
    return ExecuteDelete(
        dynamic_cast<const sql_parser::DeleteStatement &>(*stmt));

  case sql_parser::Statement::Type::SELECT:
    return ExecuteSelect(
        dynamic_cast<const sql_parser::SelectStatement &>(*stmt));

  case sql_parser::Statement::Type::USE:
    return ExecuteUse(dynamic_cast<const sql_parser::UseStatement &>(*stmt));

  case sql_parser::Statement::Type::CREATE_INDEX:
    return ExecuteCreateIndex(
        dynamic_cast<const sql_parser::CreateIndexStatement &>(*stmt));

  case sql_parser::Statement::Type::DROP_INDEX:
    return ExecuteDropIndex(
        dynamic_cast<const sql_parser::DropIndexStatement &>(*stmt));

    // TODO: 添加事务相关语句的处理
    // case sql_parser::Statement::Type::BEGIN_TRANSACTION:
    // case sql_parser::Statement::Type::COMMIT:
    // case sql_parser::Statement::Type::ROLLBACK:
    // case sql_parser::Statement::Type::SAVEPOINT:
    // case sql_parser::Statement::Type::SET_TRANSACTION:

  default: {
    SetError("Unsupported statement type: " + stmt->getTypeName());
    return "ERROR: Unsupported statement type\n";
  }
  }
}

// =====================================
// DDL语句实现 (CREATE/DROP/ALTER)
// =====================================

std::string
SqlExecutor::ExecuteCreate(const sql_parser::CreateStatement &create_stmt) {
  const std::string &table_name = NormalizeTableName(create_stmt.table_name);

  // 检查表是否已存在
  if (GetTableMetadata(table_name)) {
    SetError("Table '" + table_name + "' already exists");
    return "ERROR: Table '" + table_name + "' already exists\n";
  }

  // 验证列定义
  if (create_stmt.columns.empty()) {
    SetError("Table must have at least one column");
    return "ERROR: Table must have at least one column\n";
  }

  // 验证约束定义
  for (const auto &constraint : create_stmt.constraints) {
    if (!ValidateConstraintDefinition(constraint, create_stmt.columns)) {
      return "ERROR: Invalid constraint definition\n";
    }
  }

  // 创建表
  if (!CreateTable(table_name, create_stmt.columns, create_stmt.constraints)) {
    return "ERROR: Failed to create table\n";
  }

  // 初始化约束执行器
  CreateTableConstraints(table_name, create_stmt.constraints);

  return "Query OK, 1 table created (" + table_name + ")\n";
}

std::string
SqlExecutor::ExecuteDrop(const sql_parser::DropStatement &drop_stmt) {
  if (drop_stmt.object_type != sql_parser::DropStatement::ObjectType::TABLE) {
    SetError("Only TABLE drop is currently supported");
    return "ERROR: Only TABLE drop is currently supported\n";
  }

  const std::string &table_name = NormalizeTableName(drop_stmt.object_name);

  // 检查表是否存在
  const TableMetadata *meta = GetTableMetadata(table_name);
  if (!meta) {
    SetError("Table '" + table_name + "' does not exist");
    return "ERROR: Table '" + table_name + "' does not exist\n";
  }

  // 检查是否有外键引用
  if (HasForeignKeyReferences(table_name)) {
    SetError("Cannot drop table with foreign key references");
    return "ERROR: Cannot drop table with foreign key references\n";
  }

  // 删除表
  if (!DropTable(table_name)) {
    return "ERROR: Failed to drop table\n";
  }

  return "Query OK, 1 table dropped (" + table_name + ")\n";
}

std::string
SqlExecutor::ExecuteAlter(const sql_parser::AlterStatement &alter_stmt) {
  // TODO: 实现ALTER TABLE逻辑
  SetError("ALTER TABLE not implemented yet");
  return "ERROR: ALTER TABLE not implemented yet\n";
}

// =====================================
// DML语句实现 (INSERT/UPDATE/DELETE/SELECT)
// =====================================

std::string
SqlExecutor::ExecuteSelect(const sql_parser::SelectStatement &select_stmt) {
  const std::string &table_name =
      NormalizeTableName(select_stmt.from_clause.table_name);

  // 获取表元数据
  const TableMetadata *meta = GetTableMetadata(table_name);
  if (!meta) {
    SetError("Table '" + table_name + "' does not exist");
    return "ERROR: Table '" + table_name + "' does not exist\n";
  }

  // 解析SELECT列表
  std::vector<size_t> select_columns =
      ResolveColumnIndices(select_stmt.select_list, *meta);
  if (select_columns.empty()) {
    SetError("No valid columns selected");
    return "ERROR: No valid columns selected\n";
  }

  // 执行查询
  std::vector<Record> results =
      ExecuteSelectQuery(table_name, *meta, select_stmt);

  // 格式化结果
  return FormatQueryResults(results, select_columns, *meta);
}

std::string
SqlExecutor::ExecuteInsert(const sql_parser::InsertStatement &insert_stmt) {
  const std::string &table_name = NormalizeTableName(insert_stmt.table_name);

  // 获取表元数据
  const TableMetadata *meta = GetTableMetadata(table_name);
  if (!meta) {
    SetError("Table '" + table_name + "' does not exist");
    return "ERROR: Table '" + table_name + "' does not exist\n";
  }

  // 验证要插入的值数量
  if (insert_stmt.values.empty()) {
    SetError("No values specified for INSERT");
    return "ERROR: No values specified for INSERT\n";
  }

  // 检查每行的列数是否匹配
  size_t expected_columns = meta->columns.size();
  for (const auto &row : insert_stmt.values) {
    if (row.size() != expected_columns) {
      SetError("Column count mismatch: expected " +
               std::to_string(expected_columns) + ", got " +
               std::to_string(row.size()));
      return "ERROR: Column count mismatch\n";
    }
  }

  // 执行插入
  size_t inserted_count = 0;
  std::string error_msg;

  for (const auto &row : insert_stmt.values) {
    Record new_record(row);
    new_record.table_name = table_name;

    // 约束验证
    if (!ValidateInsertConstraints(table_name, row,
                                   GetTableSchema(table_name))) {
      error_msg = GetLastError();
      break;
    }

    uint64_t rid = 0;
    if (!InsertRecord(table_name, new_record, rid)) {
      error_msg = GetLastError();
      break;
    }

    // 更新索引 (TODO: 实现索引更新)
    // UpdateTableIndexes(table_name, new_record, rid, Operation::INSERT);

    inserted_count++;
  }

  if (!error_msg.empty()) {
    return "ERROR: " + error_msg + "\n";
  }

  return "Query OK, " + std::to_string(inserted_count) + " row(s) affected\n";
}

std::string
SqlExecutor::ExecuteUpdate(const sql_parser::UpdateStatement &update_stmt) {
  // TODO: 实现UPDATE逻辑
  SetError("UPDATE not implemented yet");
  return "ERROR: UPDATE not implemented yet\n";
}

std::string
SqlExecutor::ExecuteDelete(const sql_parser::DeleteStatement &delete_stmt) {
  // TODO: 实现DELETE逻辑
  SetError("DELETE not implemented yet");
  return "ERROR: DELETE not implemented yet\n";
}

// =====================================
// 其他语言要素
// =====================================

std::string SqlExecutor::ExecuteUse(const sql_parser::UseStatement &use_stmt) {
  current_database_ = use_stmt.database_name;
  return "Database changed to " + current_database_ + "\n";
}

std::string SqlExecutor::ExecuteCreateIndex(
    const sql_parser::CreateIndexStatement &create_index_stmt) {
  // TODO: 实现CREATE INDEX逻辑
  SetError("CREATE INDEX not implemented yet");
  return "ERROR: CREATE INDEX not implemented yet\n";
}

std::string SqlExecutor::ExecuteDropIndex(
    const sql_parser::DropIndexStatement &drop_index_stmt) {
  // TODO: 实现DROP INDEX逻辑
  SetError("DROP INDEX not implemented yet");
  return "ERROR: DROP INDEX not implemented yet\n";
}

// =====================================
// 表管理功能实现
// =====================================

bool SqlExecutor::CreateTable(
    const std::string &table_name,
    const std::vector<sql_parser::ColumnDefinition> &columns,
    const std::vector<sql_parser::TableConstraint> &constraints) {
  TableMetadata metadata;
  metadata.table_name = table_name;
  metadata.columns = columns;

  // 构建列名索引映射
  for (size_t i = 0; i < columns.size(); ++i) {
    metadata.column_indexes[columns[i].name] = i;
  }

  metadata.constraints = constraints;

  // TODO: 分配数据页面作为表根
  metadata.root_page_id = 0; // 暂时设为0

  // 保存表元数据
  table_catalog_[table_name] = std::move(metadata);

  return true;
}

bool SqlExecutor::DropTable(const std::string &table_name) {
  auto it = table_catalog_.find(table_name);
  if (it == table_catalog_.end()) {
    SetError("Table not found");
    return false;
  }

  // TODO: 释放相关数据页资源

  // 删除表元数据
  table_catalog_.erase(it);

  // 清理相关约束执行器
  table_constraints_.erase(table_name);

  return true;
}

const TableMetadata *
SqlExecutor::GetTableMetadata(const std::string &table_name) const {
  auto it = table_catalog_.find(NormalizeTableName(table_name));
  return (it != table_catalog_.end()) ? &it->second : nullptr;
}

// =====================================
// 记录管理功能实现
// =====================================

bool SqlExecutor::InsertRecord(const std::string &table_name,
                               const Record &record, uint64_t &rid_out) {
  // TODO: 实现实际的记录插入逻辑
  // 目前只是模拟，生成一个RID
  static uint64_t next_rid = 1;
  rid_out = next_rid++;

  // 更新记录计数
  auto it = table_catalog_.find(table_name);
  if (it != table_catalog_.end()) {
    it->second.record_count++;
  }

  return true;
}

bool SqlExecutor::UpdateRecord(const std::string &table_name, uint64_t rid,
                               const Record &new_record) {
  // TODO: 实现记录更新逻辑
  SetError("Update not implemented");
  return false;
}

bool SqlExecutor::DeleteRecord(const std::string &table_name, uint64_t rid) {
  // TODO: 实现记录删除逻辑
  SetError("Delete not implemented");
  return false;
}

Record SqlExecutor::GetRecord(const std::string &table_name,
                              uint64_t rid) const {
  // TODO: 实现记录获取逻辑
  return Record();
}

std::vector<Record>
SqlExecutor::GetAllRecords(const std::string &table_name) const {
  // TODO: 实现获取所有记录的逻辑
  return std::vector<Record>();
}

std::vector<Record>
SqlExecutor::QueryRecords(const std::string &table_name,
                          const WhereCondition &condition) const {
  // TODO: 实现条件查询逻辑
  return std::vector<Record>();
}

// =====================================
// 约束验证实现
// =====================================

void SqlExecutor::CreateTableConstraints(
    const std::string &table_name,
    const std::vector<sql_parser::TableConstraint> &constraints) {
  // TODO: 实现约束执行器创建逻辑
  // 为每个约束创建相应的执行器
}

std::vector<sql_parser::ColumnDefinition>
SqlExecutor::GetTableSchema(const std::string &table_name) const {
  const TableMetadata *meta = GetTableMetadata(table_name);
  if (meta) {
    return meta->columns;
  }
  return {};
}

bool SqlExecutor::ValidateConstraintDefinition(
    const sql_parser::TableConstraint &constraint,
    const std::vector<sql_parser::ColumnDefinition> &columns) const {
  // 验证约束定义的合理性
  switch (constraint.type) {
  case sql_parser::TableConstraint::Type::PRIMARY_KEY: {
    // 主键约束验证：确保列存在
    for (const auto &col_name : constraint.column_names) {
      if (std::find_if(columns.begin(), columns.end(),
                       [&col_name](const auto &col) {
                         return col.name == col_name;
                       }) == columns.end()) {
        SetError("Primary key column '" + col_name + "' does not exist");
        return false;
      }
    }
    // 验证不能有多个主键
    if (constraint.column_names.size() != 1) {
      SetError("Simple primary key must reference exactly one column");
      return false;
    }
    break;
  }

  case sql_parser::TableConstraint::Type::UNIQUE: {
    // 唯一键约束验证
    for (const auto &col_name : constraint.column_names) {
      if (std::find_if(columns.begin(), columns.end(),
                       [&col_name](const auto &col) {
                         return col.name == col_name;
                       }) == columns.end()) {
        SetError("Unique constraint column '" + col_name + "' does not exist");
        return false;
      }
    }
    break;
  }

  case sql_parser::TableConstraint::Type::CHECK: {
    // CHECK约束目前简化为总是有效
    break;
  }

  case sql_parser::TableConstraint::Type::FOREIGN_KEY: {
    // 外键约束验证：确保引用的表和列存在
    // TODO: 实现外键引用的验证
    break;
  }

  default: {
    SetError("Unsupported constraint type");
    return false;
  }
  }

  return true;
}

bool SqlExecutor::ValidateInsertConstraints(
    const std::string &table_name, const std::vector<std::string> &record,
    const std::vector<sql_parser::ColumnDefinition> &table_schema) {
  // 获取表的约束执行器列表
  auto it = table_constraints_.find(table_name);
  if (it == table_constraints_.end()) {
    // 没有约束，验证通过
    return true;
  }

  for (const auto &constraint_executor : it->second) {
    if (!constraint_executor->validateInsert(record, table_schema)) {
      SetError("Constraint violation: " +
               constraint_executor->getConstraintName());
      return false;
    }
  }

  return true;
}

bool SqlExecutor::ValidateUpdateConstraints(
    const std::string &table_name, const std::vector<std::string> &old_record,
    const std::vector<std::string> &new_record,
    const std::vector<sql_parser::ColumnDefinition> &table_schema) {
  // 获取表的约束执行器列表
  auto it = table_constraints_.find(table_name);
  if (it == table_constraints_.end()) {
    return true;
  }

  for (const auto &constraint_executor : it->second) {
    if (!constraint_executor->validateUpdate(old_record, new_record,
                                             table_schema)) {
      SetError("Constraint violation: " +
               constraint_executor->getConstraintName());
      return false;
    }
  }

  return true;
}

bool SqlExecutor::ValidateDeleteConstraints(
    const std::string &table_name, const std::vector<std::string> &record,
    const std::vector<sql_parser::ColumnDefinition> &table_schema) {
  // 主要验证外键约束：被删除的记录是否被其他表引用
  auto it = table_constraints_.find(table_name);
  if (it == table_constraints_.end()) {
    return true;
  }

  for (const auto &constraint_executor : it->second) {
    if (!constraint_executor->validateDelete(record, table_schema)) {
      SetError("Constraint violation: " +
               constraint_executor->getConstraintName());
      return false;
    }
  }

  return true;
}

// =====================================
// 结果格式化实现
// =====================================

std::string
SqlExecutor::FormatQueryResults(const std::vector<Record> &results,
                                const std::vector<size_t> &column_indices,
                                const TableMetadata &meta) const {
  if (results.empty()) {
    return "Empty set\n";
  }

  std::vector<std::string> column_names;
  std::vector<size_t> column_widths;

  // 获取列名和计算最大宽度
  for (size_t col_idx : column_indices) {
    column_names.push_back(meta.columns[col_idx].name);
    column_widths.push_back(meta.columns[col_idx].name.length());
  }

  // 计算每列的显示宽度
  for (const auto &record : results) {
    for (size_t i = 0; i < column_indices.size(); ++i) {
      size_t col_idx = column_indices[i];
      size_t data_len = record.column_values[col_idx].length();
      if (data_len > column_widths[i]) {
        column_widths[i] = data_len;
      }
    }
  }

  std::ostringstream oss;

  // 输出列名行
  oss << "+";
  for (size_t width : column_widths) {
    oss << std::string(width + 2, '-') << "+";
  }
  oss << "\n";

  oss << "|";
  for (size_t i = 0; i < column_names.size(); ++i) {
    oss << " " << std::setw(column_widths[i]) << std::left << column_names[i]
        << " |";
  }
  oss << "\n";

  // 输出分隔线
  oss << "+";
  for (size_t width : column_widths) {
    oss << std::string(width + 2, '-') << "+";
  }
  oss << "\n";

  // 输出数据行
  for (const auto &record : results) {
    oss << "|";
    for (size_t i = 0; i < column_indices.size(); ++i) {
      size_t col_idx = column_indices[i];
      oss << " " << std::setw(column_widths[i]) << std::left
          << record.column_values[col_idx] << " |";
    }
    oss << "\n";
  }

  // 输出结束线
  oss << "+";
  for (size_t width : column_widths) {
    oss << std::string(width + 2, '-') << "+";
  }
  oss << "\n";

  oss << results.size() << " rows in set\n";

  return oss.str();
}

std::string SqlExecutor::FormatTableSchema(const TableMetadata &meta) const {
  std::ostringstream oss;
  oss << "Table: " << meta.table_name << "\n";

  // 列信息
  oss << "Columns:\n";
  for (size_t i = 0; i < meta.columns.size(); ++i) {
    const auto &col = meta.columns[i];
    oss << "  " << i + 1 << ". " << col.name << " (" << col.type.ToString()
        << ")";
    if (!col.constraints.empty()) {
      oss << " [" << col.constraints << "]";
    }
    oss << "\n";
  }

  // 约束信息
  if (!meta.constraints.empty()) {
    oss << "Constraints:\n";
    for (const auto &constraint : meta.constraints) {
      oss << "  - " << constraint.constraint_name << "\n";
    }
  }

  oss << "Records: " << meta.record_count << "\n";

  return oss.str();
}

std::string
SqlExecutor::FormatTableList(const std::vector<std::string> &tables) const {
  if (tables.empty()) {
    return "Empty set\n";
  }

  std::ostringstream oss;
  oss << "+----------------+\n";
  oss << "| Tables         |\n";
  oss << "+----------------+\n";

  for (const auto &table_name : tables) {
    oss << "| " << std::setw(14) << std::left << table_name << " |\n";
  }

  oss << "+----------------+\n";
  oss << tables.size() << " row(s) in set\n";

  return oss.str();
}

// =====================================
// 公共接口实现
// =====================================

std::string SqlExecutor::ShowTableSchema(const std::string &table_name) {
  const std::string normalized_name = NormalizeTableName(table_name);
  const TableMetadata *meta = GetTableMetadata(normalized_name);

  if (!meta) {
    SetError("Table '" + table_name + "' does not exist");
    return "ERROR: Table '" + table_name + "' does not exist\n";
  }

  return FormatTableSchema(*meta);
}

std::string SqlExecutor::ListTables() {
  std::vector<std::string> table_names;
  for (const auto &pair : table_catalog_) {
    table_names.push_back(pair.first);
  }
  return FormatTableList(table_names);
}

// =====================================
// 私有辅助函数实现
// =====================================

std::vector<size_t> SqlExecutor::ResolveColumnIndices(
    const std::vector<sql_parser::SelectItem> &select_list,
    const TableMetadata &meta) const {

  std::vector<size_t> column_indices;

  if (select_list.empty()) {
    return column_indices;
  }

  // 检查是否是SELECT * (全列查询)
  if (select_list.size() == 1 && select_list[0].expression &&
      select_list[0].expression->getType() ==
          sql_parser::Expression::Type::IDENTIFIER) {

    auto *ident_expr = dynamic_cast<const sql_parser::IdentifierExpression *>(
        select_list[0].expression.get());

    if (ident_expr && ident_expr->identifier == "*") {
      // 全列查询
      for (size_t i = 0; i < meta.columns.size(); ++i) {
        column_indices.push_back(i);
      }
      return column_indices;
    }
  }

  // 解析具体的列名
  for (const auto &select_item : select_list) {
    if (select_item.expression &&
        select_item.expression->getType() ==
            sql_parser::Expression::Type::IDENTIFIER) {

      auto *ident_expr = dynamic_cast<const sql_parser::IdentifierExpression *>(
          select_item.expression.get());

      if (ident_expr) {
        auto it = meta.column_indexes.find(ident_expr->identifier);
        if (it != meta.column_indexes.end()) {
          column_indices.push_back(it->second);
        }
      }
    }
  }

  return column_indices;
}

std::vector<Record> SqlExecutor::ExecuteSelectQuery(
    const std::string &table_name, const TableMetadata &meta,
    const sql_parser::SelectStatement &select_stmt) const {

  // 解析WHERE条件
  // TODO: 实现WHERE条件解析和执行

  if (select_stmt.where_clause) {
    // 有WHERE条件，需要条件过滤
    // TODO: 实现有条件查询
    return QueryRecords(table_name, WhereCondition()); // 临时参数
  } else {
    // 无条件查询，直接返回所有记录
    return GetAllRecords(table_name);
  }
}

bool SqlExecutor::HasForeignKeyReferences(const std::string &table_name) const {
  // TODO: 实现外键引用检查
  return false;
}

void TrimString(std::string &str) {
  // 移除前导空白
  str.erase(str.begin(),
            std::find_if(str.begin(), str.end(),
                         [](unsigned char ch) { return !std::isspace(ch); }));

  // 移除尾部空白
  str.erase(std::find_if(str.rbegin(), str.rend(),
                         [](unsigned char ch) { return !std::isspace(ch); })
                .base(),
            str.end());
}

} // namespace sqlcc
